<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>amd/davinci-mathscript/escodegen.js - davinci-mathscript</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-mathscript"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/mathscript.html">mathscript</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: amd/davinci-mathscript/escodegen.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
  Copyright (C) 2015 David Holmes &lt;david.geo.holmes@gmail.com&gt;
  Copyright (C) 2012-2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  Copyright (C) 2015 Ingvar Stepanyan &lt;me@rreverser.com&gt;
  Copyright (C) 2014 Ivan Nikulin &lt;ifaaan@gmail.com&gt;
  Copyright (C) 2012-2013 Michael Ficarra &lt;escodegen.copyright@michael.ficarra.me&gt;
  Copyright (C) 2012-2013 Mathias Bynens &lt;mathias@qiwi.be&gt;
  Copyright (C) 2013 Irakli Gozalishvili &lt;rfobic@gmail.com&gt;
  Copyright (C) 2012 Robert Gust-Bardon &lt;donate@robert.gust-bardon.org&gt;
  Copyright (C) 2012 John Freeman &lt;jfreeman08@gmail.com&gt;
  Copyright (C) 2011-2012 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;
  Copyright (C) 2012 Joost-Wim Boekesteijn &lt;joost-wim@boekesteijn.nl&gt;
  Copyright (C) 2012 Kris Kowal &lt;kris.kowal@cixar.com&gt;
  Copyright (C) 2012 Arpad Borsos &lt;arpad.borsos@googlemail.com&gt;

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*global exports:true, require:true, global:true*/
&#x27;use strict&#x27;;
define([&quot;require&quot;, &quot;exports&quot;, &#x27;davinci-mathscript/estraverse&#x27;, &#x27;davinci-mathscript/esutils&#x27;], function (require, exports, estraverse, esutils) {
    var Syntax, Precedence, BinaryPrecedence, SourceNode, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
    //esutils = require(&#x27;esutils&#x27;);
    Syntax = estraverse.Syntax;
    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }
    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }
    Precedence = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };
    BinaryPrecedence = {
        &#x27;||&#x27;: Precedence.LogicalOR,
        &#x27;&amp;&amp;&#x27;: Precedence.LogicalAND,
        &#x27;|&#x27;: Precedence.BitwiseOR,
        &#x27;^&#x27;: Precedence.BitwiseXOR,
        &#x27;&amp;&#x27;: Precedence.BitwiseAND,
        &#x27;==&#x27;: Precedence.Equality,
        &#x27;!=&#x27;: Precedence.Equality,
        &#x27;===&#x27;: Precedence.Equality,
        &#x27;!==&#x27;: Precedence.Equality,
        &#x27;is&#x27;: Precedence.Equality,
        &#x27;isnt&#x27;: Precedence.Equality,
        &#x27;&lt;&#x27;: Precedence.Relational,
        &#x27;&gt;&#x27;: Precedence.Relational,
        &#x27;&lt;=&#x27;: Precedence.Relational,
        &#x27;&gt;=&#x27;: Precedence.Relational,
        &#x27;in&#x27;: Precedence.Relational,
        &#x27;instanceof&#x27;: Precedence.Relational,
        &#x27;&lt;&lt;&#x27;: Precedence.BitwiseSHIFT,
        &#x27;&gt;&gt;&#x27;: Precedence.BitwiseSHIFT,
        &#x27;&gt;&gt;&gt;&#x27;: Precedence.BitwiseSHIFT,
        &#x27;+&#x27;: Precedence.Additive,
        &#x27;-&#x27;: Precedence.Additive,
        &#x27;*&#x27;: Precedence.Multiplicative,
        &#x27;%&#x27;: Precedence.Multiplicative,
        &#x27;/&#x27;: Precedence.Multiplicative
    };
    //Flags
    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 &lt;&lt; 1, F_ALLOW_UNPARATH_NEW = 1 &lt;&lt; 2, F_FUNC_BODY = 1 &lt;&lt; 3, F_DIRECTIVE_CTX = 1 &lt;&lt; 4, F_SEMICOLON_OPT = 1 &lt;&lt; 5;
    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0x00, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: &#x27;    &#x27;,
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: &#x27;\n&#x27;,
                space: &#x27; &#x27;,
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: &#x27;single&#x27;,
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }
    function stringRepeat(str, num) {
        var result = &#x27;&#x27;;
        for (num |= 0; num &gt; 0; num &gt;&gt;&gt;= 1, str += str) {
            if (num &amp; 1) {
                result += str;
            }
        }
        return result;
    }
    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === &#x27;[object Array]&#x27;;
        };
    }
    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }
    function endsWithLineTerminator(str) {
        var len = str.length;
        return len &amp;&amp; esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }
    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }
    function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target) {
            return typeof target === &#x27;object&#x27; &amp;&amp; target instanceof Object &amp;&amp; !(target instanceof RegExp);
        }
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    }
                    else {
                        target[key] = updateDeeply({}, val);
                    }
                }
                else {
                    target[key] = val;
                }
            }
        }
        return target;
    }
    function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
            throw new Error(&#x27;Numeric literal whose value is NaN&#x27;);
        }
        if (value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0)) {
            throw new Error(&#x27;Numeric literal whose value is negative&#x27;);
        }
        if (value === 1 / 0) {
            return json ? &#x27;null&#x27; : renumber ? &#x27;1e400&#x27; : &#x27;1e+400&#x27;;
        }
        result = &#x27;&#x27; + value;
        if (!renumber || result.length &lt; 3) {
            return result;
        }
        point = result.indexOf(&#x27;.&#x27;);
        if (!json &amp;&amp; result.charCodeAt(0) === 0x30 &amp;&amp; point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace(&#x27;e+&#x27;, &#x27;e&#x27;);
        exponent = 0;
        if ((pos = temp.indexOf(&#x27;e&#x27;)) &gt; 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point &gt;= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + &#x27;&#x27;;
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += &#x27;e&#x27; + exponent;
        }
        if ((temp.length &lt; result.length || (hexadecimal &amp;&amp; value &gt; 1e12 &amp;&amp; Math.floor(value) === value &amp;&amp; (temp = &#x27;0x&#x27; + value.toString(16)).length &lt; result.length)) &amp;&amp; +temp === value) {
            result = temp;
        }
        return result;
    }
    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine
    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling &#x27;\&#x27; and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch &amp; ~1) === 0x2028) {
            return (previousIsBackslash ? &#x27;u&#x27; : &#x27;\\u&#x27;) + ((ch === 0x2028) ? &#x27;2028&#x27; : &#x27;2029&#x27;);
        }
        else if (ch === 10 || ch === 13) {
            return (previousIsBackslash ? &#x27;&#x27; : &#x27;\\&#x27;) + ((ch === 10) ? &#x27;n&#x27; : &#x27;r&#x27;);
        }
        return String.fromCharCode(ch);
    }
    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }
            flags = match[1];
            result = &#x27;&#x27;;
            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i &lt; iz; ++i) {
                ch = reg.source.charCodeAt(i);
                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {
                            characterInBrack = false;
                        }
                    }
                    else {
                        if (ch === 47) {
                            result += &#x27;\\&#x27;;
                        }
                        else if (ch === 91) {
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92; // \
                }
                else {
                    // if new RegExp(&quot;\\\n&#x27;) is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }
            return &#x27;/&#x27; + result + &#x27;/&#x27; + flags;
        }
        return result;
    }
    function escapeAllowedCharacter(code, next) {
        var hex;
        if (code === 0x08) {
            return &#x27;\\b&#x27;;
        }
        if (code === 0x0C) {
            return &#x27;\\f&#x27;;
        }
        if (code === 0x09) {
            return &#x27;\\t&#x27;;
        }
        hex = code.toString(16).toUpperCase();
        if (json || code &gt; 0xFF) {
            return &#x27;\\u&#x27; + &#x27;0000&#x27;.slice(hex.length) + hex;
        }
        else if (code === 0x0000 &amp;&amp; !esutils.code.isDecimalDigit(next)) {
            return &#x27;\\0&#x27;;
        }
        else if (code === 0x000B) {
            return &#x27;\\x0B&#x27;;
        }
        else {
            return &#x27;\\x&#x27; + &#x27;00&#x27;.slice(hex.length) + hex;
        }
    }
    function escapeDisallowedCharacter(code) {
        if (code === 0x5C) {
            return &#x27;\\\\&#x27;;
        }
        if (code === 0x0A) {
            return &#x27;\\n&#x27;;
        }
        if (code === 0x0D) {
            return &#x27;\\r&#x27;;
        }
        if (code === 0x2028) {
            return &#x27;\\u2028&#x27;;
        }
        if (code === 0x2029) {
            return &#x27;\\u2029&#x27;;
        }
        throw new Error(&#x27;Incorrectly classified character&#x27;);
    }
    function escapeDirective(str) {
        var i, iz, code, quote;
        quote = quotes === &#x27;double&#x27; ? &#x27;&quot;&#x27; : &#x27;\&#x27;&#x27;;
        for (i = 0, iz = str.length; i &lt; iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27) {
                quote = &#x27;&quot;&#x27;;
                break;
            }
            else if (code === 0x22) {
                quote = &#x27;\&#x27;&#x27;;
                break;
            }
            else if (code === 0x5C) {
                ++i;
            }
        }
        return quote + str + quote;
    }
    function escapeString(str) {
        var result = &#x27;&#x27;, i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i &lt; len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27) {
                ++singleQuotes;
            }
            else if (code === 0x22) {
                ++doubleQuotes;
            }
            else if (code === 0x2F &amp;&amp; json) {
                result += &#x27;\\&#x27;;
            }
            else if (esutils.code.isLineTerminator(code) || code === 0x5C) {
                result += escapeDisallowedCharacter(code);
                continue;
            }
            else if ((json &amp;&amp; code &lt; 0x20) || !(json || escapeless || (code &gt;= 0x20 &amp;&amp; code &lt;= 0x7E))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }
        single = !(quotes === &#x27;double&#x27; || (quotes === &#x27;auto&#x27; &amp;&amp; doubleQuotes &lt; singleQuotes));
        quote = single ? &#x27;\&#x27;&#x27; : &#x27;&quot;&#x27;;
        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i &lt; len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27 &amp;&amp; single) || (code === 0x22 &amp;&amp; !single)) {
                result += &#x27;\\&#x27;;
            }
            result += String.fromCharCode(code);
        }
        return result + quote;
    }
    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = &#x27;&#x27;;
        for (i = 0, iz = arr.length; i &lt; iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }
    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            }
            else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            }
            else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }
    function noEmptySpace() {
        return (space) ? space : &#x27; &#x27;;
    }
    function join(left, right) {
        var leftSource, rightSource, leftCharCode, rightCharCode;
        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }
        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }
        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 0x2B || leftCharCode === 0x2D) &amp;&amp; leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) &amp;&amp; esutils.code.isIdentifierPart(rightCharCode) || leftCharCode === 0x2F &amp;&amp; rightCharCode === 0x69) {
            return [left, noEmptySpace(), right];
        }
        else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }
    function addIndent(stmt) {
        return [base, stmt];
    }
    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }
    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i &gt;= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }
    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;
        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array.length; i &lt; len; ++i) {
            line = array[i];
            j = 0;
            while (j &lt; line.length &amp;&amp; esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces &gt; j) {
                spaces = j;
            }
        }
        if (typeof specialBase !== &#x27;undefined&#x27;) {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === &#x27;*&#x27;) {
                specialBase += &#x27; &#x27;;
            }
            base = specialBase;
        }
        else {
            if (spaces &amp; 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }
        for (i = 1, len = array.length; i &lt; len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join(&#x27;&#x27;) : sn;
        }
        base = previousBase;
        return array.join(&#x27;\n&#x27;);
    }
    function generateComment(comment, specialBase) {
        if (comment.type === &#x27;Line&#x27;) {
            if (endsWithLineTerminator(comment.value)) {
                return &#x27;//&#x27; + comment.value;
            }
            else {
                // Always use LineTerminator
                var result = &#x27;//&#x27; + comment.value;
                if (!preserveBlankLines) {
                    result += &#x27;\n&#x27;;
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment &amp;&amp; /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment(&#x27;/*&#x27; + comment.value + &#x27;*/&#x27;, specialBase);
        }
        return &#x27;/*&#x27; + comment.value + &#x27;*/&#x27;;
    }
    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;
        if (stmt.leadingComments &amp;&amp; stmt.leadingComments.length &gt; 0) {
            save = result;
            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];
                extRange = comment.extendedRange;
                range = comment.range;
                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count &gt; 0) {
                    result.push(stringRepeat(&#x27;\n&#x27;, count));
                    result.push(addIndent(generateComment(comment)));
                }
                else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
                prevRange = range;
                for (i = 1, len = stmt.leadingComments.length; i &lt; len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;
                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat(&#x27;\n&#x27;, count));
                    result.push(addIndent(generateComment(comment)));
                    prevRange = range;
                }
                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat(&#x27;\n&#x27;, count));
            }
            else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation &amp;&amp; stmt.type === Syntax.Program &amp;&amp; stmt.body.length === 0) {
                    result.push(&#x27;\n&#x27;);
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(&#x27;\n&#x27;);
                }
                for (i = 1, len = stmt.leadingComments.length; i &lt; len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push(&#x27;\n&#x27;);
                    }
                    result.push(addIndent(fragment));
                }
            }
            result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;
                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count &gt; 0) {
                    result.push(stringRepeat(&#x27;\n&#x27;, count));
                    result.push(addIndent(generateComment(comment)));
                }
                else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            }
            else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(&#x27; &#x27;, calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i &lt; len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        }
                        else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    }
                    else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, &#x27;\n&#x27;];
                    }
                }
            }
        }
        return result;
    }
    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;
        for (j = start; j &lt; end; j++) {
            if (sourceCode[j] === &#x27;\n&#x27;) {
                newlineCount++;
            }
        }
        for (j = 1; j &lt; newlineCount; j++) {
            result.push(newline);
        }
    }
    function parenthesize(text, current, should) {
        if (current &lt; should) {
            return [&#x27;(&#x27;, text, &#x27;)&#x27;];
        }
        return text;
    }
    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i &lt; iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }
    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];
        if (typeof verbatim === &#x27;string&#x27;) {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        }
        else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }
        return toSourceNodeWhenNeeded(result, expr);
    }
    var CodeGenerator = (function () {
        function CodeGenerator() {
        }
        CodeGenerator.prototype.generateFunctionParams = function (node) {
            var i, iz, result, hasDefault;
            hasDefault = false;
            if (node.type === Syntax.ArrowFunctionExpression &amp;&amp; !node.rest &amp;&amp; (!node.defaults || node.defaults.length === 0) &amp;&amp; node.params.length === 1 &amp;&amp; node.params[0].type === Syntax.Identifier) {
                // arg =&gt; { } case
                result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
            }
            else {
                result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
                result.push(&#x27;(&#x27;);
                if (node.defaults) {
                    hasDefault = true;
                }
                for (i = 0, iz = node.params.length; i &lt; iz; ++i) {
                    if (hasDefault &amp;&amp; node.defaults[i]) {
                        // Handle default values.
                        result.push(this.generateAssignment(node.params[i], node.defaults[i], &#x27;=&#x27;, Precedence.Assignment, E_TTT));
                    }
                    else {
                        result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 &lt; iz) {
                        result.push(&#x27;,&#x27; + space);
                    }
                }
                if (node.rest) {
                    if (node.params.length) {
                        result.push(&#x27;,&#x27; + space);
                    }
                    result.push(&#x27;...&#x27;);
                    result.push(generateIdentifier(node.rest));
                }
                result.push(&#x27;)&#x27;);
            }
            return result;
        };
        CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
            if (node.type === Syntax.Identifier) {
                return generateIdentifier(node);
            }
            return this.generateExpression(node, precedence, flags);
        };
        CodeGenerator.prototype.generateStatement = function (stmt, flags) {
            var result, fragment;
            result = this[stmt.type](stmt, flags);
            // Attach comments
            if (extra.comment) {
                result = addComments(stmt, result);
            }
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (stmt.type === Syntax.Program &amp;&amp; !safeConcatenation &amp;&amp; newline === &#x27;&#x27; &amp;&amp; fragment.charAt(fragment.length - 1) === &#x27;\n&#x27;) {
                result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, &#x27;&#x27;) : fragment.replace(/\s+$/, &#x27;&#x27;);
            }
            return toSourceNodeWhenNeeded(result, stmt);
        };
        CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
            var result, type;
            type = expr.type || Syntax.Property;
            if (extra.verbatim &amp;&amp; expr.hasOwnProperty(extra.verbatim)) {
                return generateVerbatim(expr, precedence);
            }
            result = this[type](expr, precedence, flags);
            if (extra.comment) {
                result = addComments(expr, result);
            }
            return toSourceNodeWhenNeeded(result, expr);
        };
        CodeGenerator.prototype.maybeBlock = function (stmt, flags) {
            var result, noLeadingComment, that = this;
            noLeadingComment = !extra.comment || !stmt.leadingComments;
            if (stmt.type === Syntax.BlockStatement &amp;&amp; noLeadingComment) {
                return [space, this.generateStatement(stmt, flags)];
            }
            if (stmt.type === Syntax.EmptyStatement &amp;&amp; noLeadingComment) {
                return &#x27;;&#x27;;
            }
            withIndent(function () {
                result = [
                    newline,
                    addIndent(that.generateStatement(stmt, flags))
                ];
            });
            return result;
        };
        CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
            var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            if (stmt.type === Syntax.BlockStatement &amp;&amp; (!extra.comment || !stmt.leadingComments) &amp;&amp; !ends) {
                return [result, space];
            }
            if (ends) {
                return [result, base];
            }
            return [result, newline, base];
        };
        CodeGenerator.prototype.generateFunctionBody = function (node) {
            var result, expr;
            result = this.generateFunctionParams(node);
            if (node.type === Syntax.ArrowFunctionExpression) {
                result.push(space);
                result.push(&#x27;=&gt;&#x27;);
            }
            if (node.expression) {
                result.push(space);
                expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
                if (expr.toString().charAt(0) === &#x27;{&#x27;) {
                    expr = [&#x27;(&#x27;, expr, &#x27;)&#x27;];
                }
                result.push(expr);
            }
            else {
                result.push(this.maybeBlock(node.body, S_TTFF));
            }
            return result;
        };
        CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
            var result = [&#x27;for&#x27; + space + &#x27;(&#x27;], that = this;
            withIndent(function () {
                if (stmt.left.type === Syntax.VariableDeclaration) {
                    withIndent(function () {
                        result.push(stmt.left.kind + noEmptySpace());
                        result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                    });
                }
                else {
                    result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
                }
                result = join(result, operator);
                result = [join(result, that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)), &#x27;)&#x27;];
            });
            result.push(this.maybeBlock(stmt.body, flags));
            return result;
        };
        CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
            var result = [];
            if (computed) {
                result.push(&#x27;[&#x27;);
            }
            result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
            if (computed) {
                result.push(&#x27;]&#x27;);
            }
            return result;
        };
        CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
            if (Precedence.Assignment &lt; precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize([
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ], Precedence.Assignment, precedence);
        };
        CodeGenerator.prototype.semicolon = function (flags) {
            if (!semicolons &amp;&amp; flags &amp; F_SEMICOLON_OPT) {
                return &#x27;&#x27;;
            }
            return &#x27;;&#x27;;
        };
        return CodeGenerator;
    })();
    // Helpers.
    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }
    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? &#x27;async&#x27; + (spaceRequired ? noEmptySpace() : space) : &#x27;&#x27;;
    }
    function generateStarSuffix(node) {
        var isGenerator = node.generator &amp;&amp; !extra.moz.starlessGenerator;
        return isGenerator ? &#x27;*&#x27; + space : &#x27;&#x27;;
    }
    function generateMethodPrefix(prop) {
        var func = prop.value;
        if (func.async) {
            return generateAsyncPrefix(func, !prop.computed);
        }
        else {
            // avoid space before method name
            return generateStarSuffix(func) ? &#x27;*&#x27; : &#x27;&#x27;;
        }
    }
    // Statements.
    CodeGenerator.Statement = {
        BlockStatement: function (stmt, flags) {
            var range, content, result = [&#x27;{&#x27;, newline], that = this;
            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 &amp;&amp; preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] &gt; 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === &#x27;\n&#x27;) {
                            result = [&#x27;{&#x27;];
                        }
                        result.push(content);
                    }
                }
                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags &amp; F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }
                for (i = 0, iz = stmt.body.length; i &lt; iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === &#x27;\n&#x27;) {
                                    result = [&#x27;{&#x27;];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }
                        // handle spaces between lines
                        if (i &gt; 0) {
                            if (!stmt.body[i - 1].trailingComments &amp;&amp; !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    if (stmt.body[i].leadingComments &amp;&amp; preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    }
                    else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines &amp;&amp; i &lt; iz - 1) {
                            // don&#x27;t add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        }
                        else {
                            result.push(newline);
                        }
                    }
                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });
            result.push(addIndent(&#x27;}&#x27;));
            return result;
        },
        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return &#x27;break &#x27; + stmt.label.name + this.semicolon(flags);
            }
            return &#x27;break&#x27; + this.semicolon(flags);
        },
        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return &#x27;continue &#x27; + stmt.label.name + this.semicolon(flags);
            }
            return &#x27;continue&#x27; + this.semicolon(flags);
        },
        ClassBody: function (stmt, flags) {
            var result = [&#x27;{&#x27;, newline], that = this;
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = stmt.body.length; i &lt; iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 &lt; iz) {
                        result.push(newline);
                    }
                }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push(&#x27;}&#x27;);
            return result;
        },
        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result = [&#x27;class &#x27; + stmt.id.name];
            if (stmt.superClass) {
                fragment = join(&#x27;extends&#x27;, this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },
        DirectiveStatement: function (stmt, flags) {
            if (extra.raw &amp;&amp; stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },
        DoWhileStatement: function (stmt, flags) {
            // Because &#x60;do 42 while (cond)&#x60; is Syntax Error. We need semicolon.
            var result = join(&#x27;do&#x27;, this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                &#x27;while&#x27; + space + &#x27;(&#x27;,
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                &#x27;)&#x27; + this.semicolon(flags)
            ]);
        },
        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;
                result = [
                    &#x27;catch&#x27; + space + &#x27;(&#x27;,
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    &#x27;)&#x27;
                ];
                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, &#x27; if &#x27;, guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },
        DebuggerStatement: function (stmt, flags) {
            return &#x27;debugger&#x27; + this.semicolon(flags);
        },
        EmptyStatement: function (stmt, flags) {
            return &#x27;;&#x27;;
        },
        ExportDeclaration: function (stmt, flags) {
            var result = [&#x27;export&#x27;], bodyFlags, that = this;
            bodyFlags = (flags &amp; F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;
            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            if (stmt[&#x27;default&#x27;]) {
                result = join(result, &#x27;default&#x27;);
                if (isStatement(stmt.declaration)) {
                    result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
                }
                else {
                    result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
                }
                return result;
            }
            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }
            // export * FromClause ;
            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, &#x27;{&#x27; + space + &#x27;}&#x27;);
                }
                else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                }
                else {
                    result = join(result, &#x27;{&#x27;);
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i &lt; iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 &lt; iz) {
                                result.push(&#x27;,&#x27; + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + &#x27;}&#x27;);
                }
                if (stmt.source) {
                    result = join(result, [
                        &#x27;from&#x27; + space,
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                }
                else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },
        ExpressionStatement: function (stmt, flags) {
            var result, fragment;
            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== &#x27;class&#x27;) {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }
            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== &#x27;function&#x27;) {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 || esutils.code.isWhiteSpace(code) || code === 0x2A || esutils.code.isLineTerminator(code);
            }
            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== &#x27;async&#x27;) {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i &lt; iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== &#x27;function&#x27;) {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 || esutils.code.isWhiteSpace(code) || code === 0x2A || esutils.code.isLineTerminator(code);
            }
            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 &#x27;{&#x27;, &#x27;function&#x27;, &#x27;class&#x27; is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || (directive &amp;&amp; (flags &amp; F_DIRECTIVE_CTX) &amp;&amp; stmt.expression.type === Syntax.Literal &amp;&amp; typeof stmt.expression.value === &#x27;string&#x27;)) {
                result = [&#x27;(&#x27;, result, &#x27;)&#x27; + this.semicolon(flags)];
            }
            else {
                result.push(this.semicolon(flags));
            }
            return result;
        },
        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;
            // If no ImportClause is present,
            // this should be &#x60;import ModuleSpecifier&#x60; so skip &#x60;from&#x60;
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    &#x27;import&#x27;,
                    space,
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }
            // import ImportClause FromClause ;
            result = [
                &#x27;import&#x27;
            ];
            cursor = 0;
            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                    this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }
            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(&#x27;,&#x27;);
                }
                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                        space,
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                }
                else {
                    // NamedImports
                    result.push(space + &#x27;{&#x27;);
                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from &quot;...&quot;;
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + &#x27;}&#x27; + space);
                    }
                    else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from &quot;...&quot;;
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i &lt; iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 &lt; iz) {
                                    result.push(&#x27;,&#x27; + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + &#x27;}&#x27; + space);
                    }
                }
            }
            result = join(result, [
                &#x27;from&#x27; + space,
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },
        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags &amp; F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    &#x27;=&#x27;,
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },
        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;
            result = [stmt.kind];
            bodyFlags = (flags &amp; F_ALLOW_IN) ? S_TFFF : S_FFFF;
            function block() {
                node = stmt.declarations[0];
                if (extra.comment &amp;&amp; node.leadingComments) {
                    result.push(&#x27;\n&#x27;);
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                }
                else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }
                for (i = 1, iz = stmt.declarations.length; i &lt; iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment &amp;&amp; node.leadingComments) {
                        result.push(&#x27;,&#x27; + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    }
                    else {
                        result.push(&#x27;,&#x27; + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }
            if (stmt.declarations.length &gt; 1) {
                withIndent(block);
            }
            else {
                block();
            }
            result.push(this.semicolon(flags));
            return result;
        },
        ThrowStatement: function (stmt, flags) {
            return [join(&#x27;throw&#x27;, this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
        },
        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;
            result = [&#x27;try&#x27;, this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);
            if (stmt.handlers) {
                for (i = 0, iz = stmt.handlers.length; i &lt; iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            }
            else {
                guardedHandlers = stmt.guardedHandlers || [];
                for (i = 0, iz = guardedHandlers.length; i &lt; iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }
                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i &lt; iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    }
                    else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, [&#x27;finally&#x27;, this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },
        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    &#x27;switch&#x27; + space + &#x27;(&#x27;,
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    &#x27;)&#x27; + space + &#x27;{&#x27; + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i &lt; iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent(&#x27;}&#x27;));
            return result;
        },
        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join(&#x27;case&#x27;, that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        &#x27;:&#x27;
                    ];
                }
                else {
                    result = [&#x27;default:&#x27;];
                }
                i = 0;
                iz = stmt.consequent.length;
                if (iz &amp;&amp; stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }
                if (i !== iz &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }
                bodyFlags = S_TFFF;
                for (; i &lt; iz; ++i) {
                    if (i === iz - 1 &amp;&amp; flags &amp; F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },
        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    &#x27;if&#x27; + space + &#x27;(&#x27;,
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    &#x27;)&#x27;
                ];
            });
            semicolonOptional = flags &amp; F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, [&#x27;else &#x27;, this.generateStatement(stmt.alternate, bodyFlags)]);
                }
                else {
                    result = join(result, join(&#x27;else&#x27;, this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            }
            else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },
        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [&#x27;for&#x27; + space + &#x27;(&#x27;];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    }
                    else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(&#x27;;&#x27;);
                    }
                }
                else {
                    result.push(&#x27;;&#x27;);
                }
                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(&#x27;;&#x27;);
                }
                else {
                    result.push(&#x27;;&#x27;);
                }
                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(&#x27;)&#x27;);
                }
                else {
                    result.push(&#x27;)&#x27;);
                }
            });
            result.push(this.maybeBlock(stmt.body, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },
        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement(&#x27;in&#x27;, stmt, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement(&#x27;of&#x27;, stmt, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + &#x27;:&#x27;, this.maybeBlock(stmt.body, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },
        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation &amp;&amp; iz &gt; 0 ? &#x27;\n&#x27; : &#x27;&#x27;];
            bodyFlags = S_TFTF;
            for (i = 0; i &lt; iz; ++i) {
                if (!safeConcatenation &amp;&amp; i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }
                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }
                    // handle spaces between lines
                    if (i &gt; 0) {
                        if (!stmt.body[i - 1].trailingComments &amp;&amp; !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }
                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 &lt; iz &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    }
                    else {
                        result.push(newline);
                    }
                }
                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },
        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                &#x27;function&#x27;,
                generateStarSuffix(stmt) || noEmptySpace(),
                generateIdentifier(stmt.id),
                this.generateFunctionBody(stmt)
            ];
        },
        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(&#x27;return&#x27;, this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
            }
            return [&#x27;return&#x27; + this.semicolon(flags)];
        },
        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    &#x27;while&#x27; + space + &#x27;(&#x27;,
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    &#x27;)&#x27;
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },
        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    &#x27;with&#x27; + space + &#x27;(&#x27;,
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    &#x27;)&#x27;
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags &amp; F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }
    };
    merge(CodeGenerator.prototype, CodeGenerator.Statement);
    // Expressions.
    CodeGenerator.Expression = {
        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence &lt; precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i &lt; iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 &lt; iz) {
                    result.push(&#x27;,&#x27; + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },
        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },
        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },
        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional &lt; precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize([
                this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                space + &#x27;?&#x27; + space,
                this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                space + &#x27;:&#x27; + space,
                this.generateExpression(expr.alternate, Precedence.Assignment, flags)
            ], Precedence.Conditional, precedence);
        },
        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },
        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];
            if (currentPrecedence &lt; precedence) {
                flags |= F_ALLOW_IN;
            }
            fragment = this.generateExpression(expr.left, currentPrecedence, flags);
            leftSource = fragment.toString();
            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F &amp;&amp; esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            }
            else {
                result = join(fragment, expr.operator);
            }
            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);
            if (expr.operator === &#x27;/&#x27; &amp;&amp; fragment.toString().charAt(0) === &#x27;/&#x27; || expr.operator.slice(-1) === &#x27;&lt;&#x27; &amp;&amp; fragment.toString().slice(0, 3) === &#x27;!--&#x27;) {
                // If &#x27;/&#x27; concats with &#x27;/&#x27; or &#x60;&lt;&#x60; concats with &#x60;!--&#x60;, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            }
            else {
                result = join(result, fragment);
            }
            if (expr.operator === &#x27;in&#x27; &amp;&amp; !(flags &amp; F_ALLOW_IN)) {
                return [&#x27;(&#x27;, result, &#x27;)&#x27;];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },
        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push(&#x27;(&#x27;);
            for (i = 0, iz = expr[&#x27;arguments&#x27;].length; i &lt; iz; ++i) {
                result.push(this.generateExpression(expr[&#x27;arguments&#x27;][i], Precedence.Assignment, E_TTT));
                if (i + 1 &lt; iz) {
                    result.push(&#x27;,&#x27; + space);
                }
            }
            result.push(&#x27;)&#x27;);
            if (!(flags &amp; F_ALLOW_CALL)) {
                return [&#x27;(&#x27;, result, &#x27;)&#x27;];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },
        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr[&#x27;arguments&#x27;].length;
            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags &amp; F_ALLOW_UNPARATH_NEW &amp;&amp; !parentheses &amp;&amp; length === 0) ? E_TFT : E_TFF;
            result = join(&#x27;new&#x27;, this.generateExpression(expr.callee, Precedence.New, itemFlags));
            if (!(flags &amp; F_ALLOW_UNPARATH_NEW) || parentheses || length &gt; 0) {
                result.push(&#x27;(&#x27;);
                for (i = 0, iz = length; i &lt; iz; ++i) {
                    result.push(this.generateExpression(expr[&#x27;arguments&#x27;][i], Precedence.Assignment, E_TTT));
                    if (i + 1 &lt; iz) {
                        result.push(&#x27;,&#x27; + space);
                    }
                }
                result.push(&#x27;)&#x27;);
            }
            return parenthesize(result, Precedence.New, precedence);
        },
        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags &amp; F_ALLOW_CALL) ? E_TTF : E_TFF)];
            if (expr.computed) {
                result.push(&#x27;[&#x27;);
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags &amp; F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(&#x27;]&#x27;);
            }
            else {
                if (expr.object.type === Syntax.Literal &amp;&amp; typeof expr.object.value === &#x27;number&#x27;) {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don&#x27;t have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (fragment.indexOf(&#x27;.&#x27;) &lt; 0 &amp;&amp; !/[eExX]/.test(fragment) &amp;&amp; esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &amp;&amp; !(fragment.length &gt;= 2 &amp;&amp; fragment.charCodeAt(0) === 48)) {
                        result.push(&#x27;.&#x27;);
                    }
                }
                result.push(&#x27;.&#x27;);
                result.push(generateIdentifier(expr.property));
            }
            return parenthesize(result, Precedence.Member, precedence);
        },
        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
            if (space === &#x27;&#x27;) {
                result = join(expr.operator, fragment);
            }
            else {
                result = [expr.operator];
                if (expr.operator.length &gt; 2) {
                    // delete, void, typeof
                    // get &#x60;typeof []&#x60;, not &#x60;typeof[]&#x60;
                    result = join(result, fragment);
                }
                else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, &#x60;!cond&#x60;
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);
                    if (((leftCharCode === 0x2B || leftCharCode === 0x2D) &amp;&amp; leftCharCode === rightCharCode) || (esutils.code.isIdentifierPart(leftCharCode) &amp;&amp; esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    }
                    else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },
        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = &#x27;yield*&#x27;;
            }
            else {
                result = &#x27;yield&#x27;;
            }
            if (expr.argument) {
                result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },
        AwaitExpression: function (expr, precedence, flags) {
            var result = join(expr.delegate ? &#x27;await*&#x27; : &#x27;await&#x27;, this.generateExpression(expr.argument, Precedence.Await, E_TTT));
            return parenthesize(result, Precedence.Await, precedence);
        },
        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize([
                    expr.operator,
                    this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                ], Precedence.Unary, precedence);
            }
            return parenthesize([
                this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                expr.operator
            ], Precedence.Postfix, precedence);
        },
        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                &#x27;function&#x27;
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            }
            else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },
        ExportBatchSpecifier: function (expr, precedence, flags) {
            return &#x27;*&#x27;;
        },
        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags);
        },
        ArrayExpression: function (expr, precedence, flags) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return &#x27;[]&#x27;;
            }
            multiline = expr.elements.length &gt; 1;
            result = [&#x27;[&#x27;, multiline ? newline : &#x27;&#x27;];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i &lt; iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(&#x27;,&#x27;);
                        }
                    }
                    else {
                        result.push(multiline ? indent : &#x27;&#x27;);
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 &lt; iz) {
                        result.push(&#x27;,&#x27; + (multiline ? newline : space));
                    }
                }
            });
            if (multiline &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : &#x27;&#x27;);
            result.push(&#x27;]&#x27;);
            return result;
        },
        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = [&#x27;class&#x27;];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join(&#x27;extends&#x27;, this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },
        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr[&#x27;static&#x27;]) {
                result = [&#x27;static&#x27; + space];
            }
            else {
                result = [];
            }
            if (expr.kind === &#x27;get&#x27; || expr.kind === &#x27;set&#x27;) {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            }
            else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },
        Property: function (expr, precedence, flags) {
            if (expr.kind === &#x27;get&#x27; || expr.kind === &#x27;set&#x27;) {
                return [
                    expr.kind,
                    noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            if (expr.shorthand) {
                return this.generatePropertyKey(expr.key, expr.computed);
            }
            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return [
                this.generatePropertyKey(expr.key, expr.computed),
                &#x27;:&#x27; + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },
        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;
            if (!expr.properties.length) {
                return &#x27;{}&#x27;;
            }
            multiline = expr.properties.length &gt; 1;
            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });
            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [&#x27;{&#x27;, space, fragment, space, &#x27;}&#x27;];
                }
            }
            withIndent(function (indent) {
                var i, iz;
                result = [&#x27;{&#x27;, newline, indent, fragment];
                if (multiline) {
                    result.push(&#x27;,&#x27; + newline);
                    for (i = 1, iz = expr.properties.length; i &lt; iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 &lt; iz) {
                            result.push(&#x27;,&#x27; + newline);
                        }
                    }
                }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push(&#x27;}&#x27;);
            return result;
        },
        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return &#x27;{}&#x27;;
            }
            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            }
            else {
                for (i = 0, iz = expr.properties.length; i &lt; iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = [&#x27;{&#x27;, multiline ? newline : &#x27;&#x27;];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i &lt; iz; ++i) {
                    result.push(multiline ? indent : &#x27;&#x27;);
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 &lt; iz) {
                        result.push(&#x27;,&#x27; + (multiline ? newline : space));
                    }
                }
            });
            if (multiline &amp;&amp; !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : &#x27;&#x27;);
            result.push(&#x27;}&#x27;);
            return result;
        },
        ThisExpression: function (expr, precedence, flags) {
            return &#x27;this&#x27;;
        },
        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },
        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id);
        },
        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = [&#x27;*&#x27;];
            if (expr.id) {
                result.push(space + &#x27;as&#x27; + noEmptySpace() + generateIdentifier(expr.id));
            }
            return result;
        },
        ImportSpecifier: function (expr, precedence, flags) {
            return this.ExportSpecifier(expr, precedence, flags);
        },
        ExportSpecifier: function (expr, precedence, flags) {
            var result = [expr.id.name];
            if (expr.name) {
                result.push(noEmptySpace() + &#x27;as&#x27; + noEmptySpace() + generateIdentifier(expr.name));
            }
            return result;
        },
        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty(&#x27;raw&#x27;) &amp;&amp; parse &amp;&amp; extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                }
                catch (e) {
                }
            }
            if (expr.value === null) {
                return &#x27;null&#x27;;
            }
            if (typeof expr.value === &#x27;string&#x27;) {
                return escapeString(expr.value);
            }
            if (typeof expr.value === &#x27;number&#x27;) {
                return generateNumber(expr.value);
            }
            if (typeof expr.value === &#x27;boolean&#x27;) {
                return expr.value ? &#x27;true&#x27; : &#x27;false&#x27;;
            }
            return generateRegExp(expr.value);
        },
        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },
        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? [&#x27;(&#x27;] : [&#x27;[&#x27;];
            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }
            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i &lt; iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i &gt; 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        }
                        else {
                            result.push(fragment);
                        }
                    }
                });
            }
            if (expr.filter) {
                result = join(result, &#x27;if&#x27; + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [&#x27;(&#x27;, fragment, &#x27;)&#x27;]);
            }
            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result = join(result, fragment);
            }
            result.push((expr.type === Syntax.GeneratorExpression) ? &#x27;)&#x27; : &#x27;]&#x27;);
            return result;
        },
        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind,
                    noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            }
            else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }
            fragment = join(fragment, expr.of ? &#x27;of&#x27; : &#x27;in&#x27;);
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
            return [&#x27;for&#x27; + space + &#x27;(&#x27;, fragment, &#x27;)&#x27;];
        },
        SpreadElement: function (expr, precedence, flags) {
            return [
                &#x27;...&#x27;,
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },
        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags &amp; F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },
        TemplateElement: function (expr, precedence, flags) {
            // Don&#x27;t use &quot;cooked&quot;. Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },
        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [&#x27;&#x60;&#x27;];
            for (i = 0, iz = expr.quasis.length; i &lt; iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 &lt; iz) {
                    result.push(&#x27;${&#x27; + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + &#x27;}&#x27;);
                }
            }
            result.push(&#x27;&#x60;&#x27;);
            return result;
        },
        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        }
    };
    merge(CodeGenerator.prototype, CodeGenerator.Expression);
    function generateInternal(node) {
        var codegen;
        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }
        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }
        throw new Error(&#x27;Unknown node type: &#x27; + node.type);
    }
    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;
        if (options != null) {
            // Obsolete options
            //
            //   &#x60;options.indent&#x60;
            //   &#x60;options.base&#x60;
            //
            // Instead of them, we can use &#x60;option.format.indent&#x60;.
            if (typeof options.indent === &#x27;string&#x27;) {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === &#x27;number&#x27;) {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === &#x27;string&#x27;) {
                base = options.base;
            }
            else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        }
        else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? &#x27;double&#x27; : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = &#x27;&#x27;;
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines &amp;&amp; sourceCode !== null;
        extra = options;
        result = generateInternal(node);
        if (!sourceMap) {
            pair = { code: result.toString(), map: null };
            return options.sourceMapWithCode ? pair : pair.code;
        }
        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });
        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap, options.sourceContent);
        }
        if (options.sourceMapWithCode) {
            return pair;
        }
        return pair.map.toString();
    }
    FORMAT_MINIFY = {
        indent: {
            style: &#x27;&#x27;,
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: &#x27;auto&#x27;,
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };
    FORMAT_DEFAULTS = getDefaultOptions().format;
    var escodegen = {
        generate: generate,
        Precedence: updateDeeply({}, Precedence),
        FORMAT_MINIFY: FORMAT_MINIFY,
        FORMAT_DEFAULT: FORMAT_DEFAULTS
    };
    return escodegen;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
