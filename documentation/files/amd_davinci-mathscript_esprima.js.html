<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>amd/davinci-mathscript/esprima.js - davinci-mathscript</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-mathscript"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.8</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/mathscript.html">mathscript</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: amd/davinci-mathscript/esprima.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
  Copyright (C) 2015 David Holmes &lt;david.geo.holmes@gmail.com&gt;
  Copyright (C) 2013 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;
  Copyright (C) 2013 Thaddee Tyl &lt;thaddee.tyl@gmail.com&gt;
  Copyright (C) 2013 Mathias Bynens &lt;mathias@qiwi.be&gt;
  Copyright (C) 2012 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;
  Copyright (C) 2012 Mathias Bynens &lt;mathias@qiwi.be&gt;
  Copyright (C) 2012 Joost-Wim Boekesteijn &lt;joost-wim@boekesteijn.nl&gt;
  Copyright (C) 2012 Kris Kowal &lt;kris.kowal@cixar.com&gt;
  Copyright (C) 2012 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  Copyright (C) 2012 Arpad Borsos &lt;arpad.borsos@googlemail.com&gt;
  Copyright (C) 2011 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
define([&quot;require&quot;, &quot;exports&quot;], function (require, exports) {
    var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, PropertyKind, Messages, Regex, source, strict, index, lineNumber, lineStart, length, lookahead, state, extra;
    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };
    TokenName = {};
    TokenName[Token.BooleanLiteral] = &#x27;Boolean&#x27;;
    TokenName[Token.EOF] = &#x27;&lt;end&gt;&#x27;;
    TokenName[Token.Identifier] = &#x27;Identifier&#x27;;
    TokenName[Token.Keyword] = &#x27;Keyword&#x27;;
    TokenName[Token.NullLiteral] = &#x27;Null&#x27;;
    TokenName[Token.NumericLiteral] = &#x27;Numeric&#x27;;
    TokenName[Token.Punctuator] = &#x27;Punctuator&#x27;;
    TokenName[Token.StringLiteral] = &#x27;String&#x27;;
    TokenName[Token.RegularExpression] = &#x27;RegularExpression&#x27;;
    // A function following one of those tokens is an expression.
    FnExprTokens = [&#x27;(&#x27;, &#x27;{&#x27;, &#x27;[&#x27;, &#x27;in&#x27;, &#x27;typeof&#x27;, &#x27;instanceof&#x27;, &#x27;new&#x27;, &#x27;return&#x27;, &#x27;case&#x27;, &#x27;delete&#x27;, &#x27;throw&#x27;, &#x27;void&#x27;, &#x27;=&#x27;, &#x27;+=&#x27;, &#x27;-=&#x27;, &#x27;*=&#x27;, &#x27;/=&#x27;, &#x27;%=&#x27;, &#x27;&lt;&lt;=&#x27;, &#x27;&gt;&gt;=&#x27;, &#x27;&gt;&gt;&gt;=&#x27;, &#x27;&amp;=&#x27;, &#x27;|=&#x27;, &#x27;^=&#x27;, &#x27;,&#x27;, &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;%&#x27;, &#x27;++&#x27;, &#x27;--&#x27;, &#x27;&lt;&lt;&#x27;, &#x27;&gt;&gt;&#x27;, &#x27;&gt;&gt;&gt;&#x27;, &#x27;&amp;&#x27;, &#x27;|&#x27;, &#x27;^&#x27;, &#x27;!&#x27;, &#x27;~&#x27;, &#x27;&amp;&amp;&#x27;, &#x27;||&#x27;, &#x27;?&#x27;, &#x27;:&#x27;, &#x27;===&#x27;, &#x27;==&#x27;, &#x27;&gt;=&#x27;, &#x27;&lt;=&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;!=&#x27;, &#x27;!==&#x27;];
    Syntax = {
        AssignmentExpression: &#x27;AssignmentExpression&#x27;,
        ArrayExpression: &#x27;ArrayExpression&#x27;,
        ArrowFunctionExpression: &#x27;ArrowFunctionExpression&#x27;,
        BlockStatement: &#x27;BlockStatement&#x27;,
        BinaryExpression: &#x27;BinaryExpression&#x27;,
        BreakStatement: &#x27;BreakStatement&#x27;,
        CallExpression: &#x27;CallExpression&#x27;,
        CatchClause: &#x27;CatchClause&#x27;,
        ConditionalExpression: &#x27;ConditionalExpression&#x27;,
        ContinueStatement: &#x27;ContinueStatement&#x27;,
        DoWhileStatement: &#x27;DoWhileStatement&#x27;,
        DebuggerStatement: &#x27;DebuggerStatement&#x27;,
        EmptyStatement: &#x27;EmptyStatement&#x27;,
        ExpressionStatement: &#x27;ExpressionStatement&#x27;,
        ForStatement: &#x27;ForStatement&#x27;,
        ForInStatement: &#x27;ForInStatement&#x27;,
        FunctionDeclaration: &#x27;FunctionDeclaration&#x27;,
        FunctionExpression: &#x27;FunctionExpression&#x27;,
        Identifier: &#x27;Identifier&#x27;,
        IfStatement: &#x27;IfStatement&#x27;,
        Literal: &#x27;Literal&#x27;,
        LabeledStatement: &#x27;LabeledStatement&#x27;,
        LogicalExpression: &#x27;LogicalExpression&#x27;,
        MemberExpression: &#x27;MemberExpression&#x27;,
        NewExpression: &#x27;NewExpression&#x27;,
        ObjectExpression: &#x27;ObjectExpression&#x27;,
        Program: &#x27;Program&#x27;,
        Property: &#x27;Property&#x27;,
        ReturnStatement: &#x27;ReturnStatement&#x27;,
        SequenceExpression: &#x27;SequenceExpression&#x27;,
        SwitchStatement: &#x27;SwitchStatement&#x27;,
        SwitchCase: &#x27;SwitchCase&#x27;,
        ThisExpression: &#x27;ThisExpression&#x27;,
        ThrowStatement: &#x27;ThrowStatement&#x27;,
        TryStatement: &#x27;TryStatement&#x27;,
        UnaryExpression: &#x27;UnaryExpression&#x27;,
        UpdateExpression: &#x27;UpdateExpression&#x27;,
        VariableDeclaration: &#x27;VariableDeclaration&#x27;,
        VariableDeclarator: &#x27;VariableDeclarator&#x27;,
        WhileStatement: &#x27;WhileStatement&#x27;,
        WithStatement: &#x27;WithStatement&#x27;
    };
    PlaceHolders = {
        ArrowParameterPlaceHolder: {
            type: &#x27;ArrowParameterPlaceHolder&#x27;
        }
    };
    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };
    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: &#x27;Unexpected token %0&#x27;,
        UnexpectedNumber: &#x27;Unexpected number&#x27;,
        UnexpectedString: &#x27;Unexpected string&#x27;,
        UnexpectedIdentifier: &#x27;Unexpected identifier&#x27;,
        UnexpectedReserved: &#x27;Unexpected reserved word&#x27;,
        UnexpectedEOS: &#x27;Unexpected end of input&#x27;,
        NewlineAfterThrow: &#x27;Illegal newline after throw&#x27;,
        InvalidRegExp: &#x27;Invalid regular expression&#x27;,
        UnterminatedRegExp: &#x27;Invalid regular expression: missing /&#x27;,
        InvalidLHSInAssignment: &#x27;Invalid left-hand side in assignment&#x27;,
        InvalidLHSInForIn: &#x27;Invalid left-hand side in for-in&#x27;,
        MultipleDefaultsInSwitch: &#x27;More than one default clause in switch statement&#x27;,
        NoCatchOrFinally: &#x27;Missing catch or finally after try&#x27;,
        UnknownLabel: &#x27;Undefined label \&#x27;%0\&#x27;&#x27;,
        Redeclaration: &#x27;%0 \&#x27;%1\&#x27; has already been declared&#x27;,
        IllegalContinue: &#x27;Illegal continue statement&#x27;,
        IllegalBreak: &#x27;Illegal break statement&#x27;,
        IllegalReturn: &#x27;Illegal return statement&#x27;,
        StrictModeWith: &#x27;Strict mode code may not include a with statement&#x27;,
        StrictCatchVariable: &#x27;Catch variable may not be eval or arguments in strict mode&#x27;,
        StrictVarName: &#x27;Variable name may not be eval or arguments in strict mode&#x27;,
        StrictParamName: &#x27;Parameter name eval or arguments is not allowed in strict mode&#x27;,
        StrictParamDupe: &#x27;Strict mode function may not have duplicate parameter names&#x27;,
        StrictFunctionName: &#x27;Function name may not be eval or arguments in strict mode&#x27;,
        StrictOctalLiteral: &#x27;Octal literals are not allowed in strict mode.&#x27;,
        StrictDelete: &#x27;Delete of an unqualified identifier in strict mode.&#x27;,
        StrictDuplicateProperty: &#x27;Duplicate data property in object literal not allowed in strict mode&#x27;,
        AccessorDataProperty: &#x27;Object literal may not have data and accessor property with the same name&#x27;,
        AccessorGetSet: &#x27;Object literal may not have multiple get/set accessors with the same name&#x27;,
        StrictLHSAssignment: &#x27;Assignment to eval or arguments is not allowed in strict mode&#x27;,
        StrictLHSPostfix: &#x27;Postfix increment/decrement may not have eval or arguments operand in strict mode&#x27;,
        StrictLHSPrefix: &#x27;Prefix increment/decrement may not have eval or arguments operand in strict mode&#x27;,
        StrictReservedWord: &#x27;Use of future reserved word in strict mode&#x27;
    };
    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp(&#x27;[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]&#x27;),
        NonAsciiIdentifierPart: new RegExp(&#x27;[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]&#x27;)
    };
    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.
    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error(&#x27;ASSERT: &#x27; + message);
        }
    }
    function isDecimalDigit(ch) {
        return (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39); // 0..9
    }
    function isHexDigit(ch) {
        return &#x27;0123456789abcdefABCDEF&#x27;.indexOf(ch) &gt;= 0;
    }
    function isOctalDigit(ch) {
        return &#x27;01234567&#x27;.indexOf(ch) &gt;= 0;
    }
    // 7.2 White Space
    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) || (ch &gt;= 0x1680 &amp;&amp; [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) &gt;= 0);
    }
    // 7.3 Line Terminators
    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }
    // 7.6 Identifier Names and Identifiers
    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x5A) || (ch &gt;= 0x61 &amp;&amp; ch &lt;= 0x7A) || (ch === 0x5C) || ((ch &gt;= 0x80) &amp;&amp; Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }
    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x5A) || (ch &gt;= 0x61 &amp;&amp; ch &lt;= 0x7A) || (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39) || (ch === 0x5C) || ((ch &gt;= 0x80) &amp;&amp; Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }
    // 7.6.1.2 Future Reserved Words
    function isFutureReservedWord(id) {
        switch (id) {
            case &#x27;class&#x27;:
            case &#x27;enum&#x27;:
            case &#x27;export&#x27;:
            case &#x27;extends&#x27;:
            case &#x27;import&#x27;:
            case &#x27;super&#x27;:
                return true;
            default:
                return false;
        }
    }
    function isStrictModeReservedWord(id) {
        switch (id) {
            case &#x27;implements&#x27;:
            case &#x27;interface&#x27;:
            case &#x27;package&#x27;:
            case &#x27;private&#x27;:
            case &#x27;protected&#x27;:
            case &#x27;public&#x27;:
            case &#x27;static&#x27;:
            case &#x27;yield&#x27;:
            case &#x27;let&#x27;:
                return true;
            default:
                return false;
        }
    }
    function isRestrictedWord(id) {
        return id === &#x27;eval&#x27; || id === &#x27;arguments&#x27;;
    }
    // 7.6.1.1 Keywords
    function isKeyword(id) {
        if (strict &amp;&amp; isStrictModeReservedWord(id)) {
            return true;
        }
        switch (id.length) {
            case 2:
                return (id === &#x27;if&#x27;) || (id === &#x27;in&#x27;) || (id === &#x27;do&#x27;);
            case 3:
                return (id === &#x27;var&#x27;) || (id === &#x27;for&#x27;) || (id === &#x27;new&#x27;) || (id === &#x27;try&#x27;) || (id === &#x27;let&#x27;);
            case 4:
                return (id === &#x27;this&#x27;) || (id === &#x27;else&#x27;) || (id === &#x27;case&#x27;) || (id === &#x27;void&#x27;) || (id === &#x27;with&#x27;) || (id === &#x27;enum&#x27;);
            case 5:
                return (id === &#x27;while&#x27;) || (id === &#x27;break&#x27;) || (id === &#x27;catch&#x27;) || (id === &#x27;throw&#x27;) || (id === &#x27;const&#x27;) || (id === &#x27;yield&#x27;) || (id === &#x27;class&#x27;) || (id === &#x27;super&#x27;);
            case 6:
                return (id === &#x27;return&#x27;) || (id === &#x27;typeof&#x27;) || (id === &#x27;delete&#x27;) || (id === &#x27;switch&#x27;) || (id === &#x27;export&#x27;) || (id === &#x27;import&#x27;);
            case 7:
                return (id === &#x27;default&#x27;) || (id === &#x27;finally&#x27;) || (id === &#x27;extends&#x27;);
            case 8:
                return (id === &#x27;function&#x27;) || (id === &#x27;continue&#x27;) || (id === &#x27;debugger&#x27;);
            case 10:
                return (id === &#x27;instanceof&#x27;);
            default:
                return false;
        }
    }
    // 7.4 Comments
    function addComment(type, value, start, end, loc) {
        var comment;
        assert(typeof start === &#x27;number&#x27;, &#x27;Comment must have valid position&#x27;);
        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart &gt;= start) {
            return;
        }
        state.lastCommentStart = start;
        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }
    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;
        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };
        while (index &lt; length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment(&#x27;Line&#x27;, comment, start, index - 1, loc);
                }
                if (ch === 13 &amp;&amp; source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }
        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment(&#x27;Line&#x27;, comment, start, index, loc);
        }
    }
    function skipMultiLineComment() {
        var start, loc, ch, comment;
        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }
        while (index &lt; length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D &amp;&amp; source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index &gt;= length) {
                    throwUnexpectedToken();
                }
            }
            else if (ch === 0x2A) {
                // Block comment ends with &#x27;*/&#x27;.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment(&#x27;Block&#x27;, comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            }
            else {
                ++index;
            }
        }
        throwUnexpectedToken();
    }
    function skipComment() {
        var ch, start;
        start = (index === 0);
        while (index &lt; length) {
            ch = source.charCodeAt(index);
            if (isWhiteSpace(ch)) {
                ++index;
            }
            else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D &amp;&amp; source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            }
            else if (ch === 0x2F) {
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                }
                else if (ch === 0x2A) {
                    ++index;
                    ++index;
                    skipMultiLineComment();
                }
                else {
                    break;
                }
            }
            else if (start &amp;&amp; ch === 0x2D) {
                // U+003E is &#x27;&gt;&#x27;
                if ((source.charCodeAt(index + 1) === 0x2D) &amp;&amp; (source.charCodeAt(index + 2) === 0x3E)) {
                    // &#x27;--&gt;&#x27; is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                }
                else {
                    break;
                }
            }
            else if (ch === 0x3C) {
                if (source.slice(index + 1, index + 4) === &#x27;!--&#x27;) {
                    ++index; // &#x60;&lt;&#x60;
                    ++index; // &#x60;!&#x60;
                    ++index; // &#x60;-&#x60;
                    ++index; // &#x60;-&#x60;
                    skipSingleLineComment(4);
                }
                else {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = (prefix === &#x27;u&#x27;) ? 4 : 2;
        for (i = 0; i &lt; len; ++i) {
            if (index &lt; length &amp;&amp; isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + &#x27;0123456789abcdef&#x27;.indexOf(ch.toLowerCase());
            }
            else {
                return &#x27;&#x27;;
            }
        }
        return String.fromCharCode(code);
    }
    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;
        ch = source[index];
        code = 0;
        // At least, one hex digit is required.
        if (ch === &#x27;}&#x27;) {
            throwUnexpectedToken();
        }
        while (index &lt; length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + &#x27;0123456789abcdef&#x27;.indexOf(ch.toLowerCase());
        }
        if (code &gt; 0x10FFFF || ch !== &#x27;}&#x27;) {
            throwUnexpectedToken();
        }
        // UTF-16 Encoding
        if (code &lt;= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) &gt;&gt; 10) + 0xD800;
        cu2 = ((code - 0x10000) &amp; 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }
    function getEscapedIdentifier() {
        var ch, id;
        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);
        // &#x27;\u&#x27; (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape(&#x27;u&#x27;);
            if (!ch || ch === &#x27;\\&#x27; || !isIdentifierStart(ch.charCodeAt(0))) {
                throwUnexpectedToken();
            }
            id = ch;
        }
        while (index &lt; length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);
            // &#x27;\u&#x27; (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                ch = scanHexEscape(&#x27;u&#x27;);
                if (!ch || ch === &#x27;\\&#x27; || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwUnexpectedToken();
                }
                id += ch;
            }
        }
        return id;
    }
    function getIdentifier() {
        var start, ch;
        start = index++;
        while (index &lt; length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            }
            else {
                break;
            }
        }
        return source.slice(start, index);
    }
    function scanIdentifier() {
        var start, id, type;
        start = index;
        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();
        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        }
        else if (isKeyword(id)) {
            type = Token.Keyword;
        }
        else if (id === &#x27;null&#x27;) {
            type = Token.NullLiteral;
        }
        else if (id === &#x27;true&#x27; || id === &#x27;false&#x27;) {
            type = Token.BooleanLiteral;
        }
        else {
            type = Token.Identifier;
        }
        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    // 7.7 Punctuators
    function scanPunctuator() {
        var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
        switch (code) {
            case 0x2E:
            case 0x28:
            case 0x29:
            case 0x3B:
            case 0x2C:
            case 0x7B:
            case 0x7D:
            case 0x5B:
            case 0x5D:
            case 0x3A:
            case 0x3F:
            case 0x7E:
                ++index;
                if (extra.tokenize) {
                    if (code === 0x28) {
                        extra.openParenToken = extra.tokens.length;
                    }
                    else if (code === 0x7B) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                };
            default:
                code2 = source.charCodeAt(index + 1);
                // &#x27;=&#x27; (U+003D) marks an assignment or comparison operator.
                if (code2 === 0x3D) {
                    switch (code) {
                        case 0x2B:
                        case 0x2D:
                        case 0x2F:
                        case 0x3C:
                        case 0x3E:
                        case 0x5E:
                        case 0x7C:
                        case 0x25:
                        case 0x26:
                        case 0x2A:
                            index += 2;
                            return {
                                type: Token.Punctuator,
                                value: String.fromCharCode(code) + String.fromCharCode(code2),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: start,
                                end: index
                            };
                        case 0x21:
                        case 0x3D:
                            index += 2;
                            // !== and ===
                            if (source.charCodeAt(index) === 0x3D) {
                                ++index;
                            }
                            return {
                                type: Token.Punctuator,
                                value: source.slice(start, index),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: start,
                                end: index
                            };
                    }
                }
        }
        // 4-character punctuator: &gt;&gt;&gt;=
        ch4 = source.substr(index, 4);
        if (ch4 === &#x27;&gt;&gt;&gt;=&#x27;) {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // 3-character punctuators: === !== &gt;&gt;&gt; &lt;&lt;= &gt;&gt;=
        ch3 = ch4.substr(0, 3);
        if (ch3 === &#x27;&gt;&gt;&gt;&#x27; || ch3 === &#x27;&lt;&lt;=&#x27; || ch3 === &#x27;&gt;&gt;=&#x27;) {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // Other 2-character punctuators: ++ -- &lt;&lt; &gt;&gt; &amp;&amp; ||
        ch2 = ch3.substr(0, 2);
        if ((ch1 === ch2[1] &amp;&amp; (&#x27;+-&lt;&gt;&amp;|&#x27;.indexOf(ch1) &gt;= 0)) || ch2 === &#x27;=&gt;&#x27;) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // 1-character punctuators: &lt; &gt; = ! + - * % &amp; | ^ /
        if (&#x27;&lt;&gt;=!+-*%&amp;|^/&#x27;.indexOf(ch1) &gt;= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        throwUnexpectedToken();
    }
    // 7.8.3 Numeric Literals
    function scanHexLiteral(start) {
        var number = &#x27;&#x27;;
        while (index &lt; length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }
        if (number.length === 0) {
            throwUnexpectedToken();
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt(&#x27;0x&#x27; + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function scanBinaryLiteral(start) {
        var ch, number;
        number = &#x27;&#x27;;
        while (index &lt; length) {
            ch = source[index];
            if (ch !== &#x27;0&#x27; &amp;&amp; ch !== &#x27;1&#x27;) {
                break;
            }
            number += source[index++];
        }
        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }
        if (index &lt; length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function scanOctalLiteral(prefix, start) {
        var number, octal;
        if (isOctalDigit(prefix)) {
            octal = true;
            number = &#x27;0&#x27; + source[index++];
        }
        else {
            octal = false;
            ++index;
            number = &#x27;&#x27;;
        }
        while (index &lt; length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }
        if (!octal &amp;&amp; number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function isImplicitOctalLiteral() {
        var i, ch;
        for (i = index + 1; i &lt; length; ++i) {
            ch = source[i];
            if (ch === &#x27;8&#x27; || ch === &#x27;9&#x27;) {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }
        return true;
    }
    function scanNumericLiteral() {
        var number, start, ch;
        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === &#x27;.&#x27;), &#x27;Numeric literal must start with a decimal digit or a decimal point&#x27;);
        start = index;
        number = &#x27;&#x27;;
        if (ch !== &#x27;.&#x27;) {
            number = source[index++];
            ch = source[index];
            // Hex number starts with &#x27;0x&#x27;.
            // Octal number starts with &#x27;0&#x27;.
            // Octal number in ES6 starts with &#x27;0o&#x27;.
            // Binary number in ES6 starts with &#x27;0b&#x27;.
            if (number === &#x27;0&#x27;) {
                if (ch === &#x27;x&#x27; || ch === &#x27;X&#x27;) {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === &#x27;b&#x27; || ch === &#x27;B&#x27;) {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === &#x27;o&#x27; || ch === &#x27;O&#x27;) {
                    return scanOctalLiteral(ch, start);
                }
                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }
        if (ch === &#x27;.&#x27;) {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }
        if (ch === &#x27;e&#x27; || ch === &#x27;E&#x27;) {
            number += source[index++];
            ch = source[index];
            if (ch === &#x27;+&#x27; || ch === &#x27;-&#x27;) {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            }
            else {
                throwUnexpectedToken();
            }
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }
        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    // 7.8.4 String Literals
    function scanStringLiteral() {
        var str = &#x27;&#x27;, quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        quote = source[index];
        assert((quote === &#x27;\&#x27;&#x27; || quote === &#x27;&quot;&#x27;), &#x27;String literal must starts with a quote&#x27;);
        start = index;
        ++index;
        while (index &lt; length) {
            ch = source[index++];
            if (ch === quote) {
                quote = &#x27;&#x27;;
                break;
            }
            else if (ch === &#x27;\\&#x27;) {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case &#x27;u&#x27;:
                        case &#x27;x&#x27;:
                            if (source[index] === &#x27;{&#x27;) {
                                ++index;
                                str += scanUnicodeCodePointEscape();
                            }
                            else {
                                restore = index;
                                unescaped = scanHexEscape(ch);
                                if (unescaped) {
                                    str += unescaped;
                                }
                                else {
                                    index = restore;
                                    str += ch;
                                }
                            }
                            break;
                        case &#x27;n&#x27;:
                            str += &#x27;\n&#x27;;
                            break;
                        case &#x27;r&#x27;:
                            str += &#x27;\r&#x27;;
                            break;
                        case &#x27;t&#x27;:
                            str += &#x27;\t&#x27;;
                            break;
                        case &#x27;b&#x27;:
                            str += &#x27;\b&#x27;;
                            break;
                        case &#x27;f&#x27;:
                            str += &#x27;\f&#x27;;
                            break;
                        case &#x27;v&#x27;:
                            str += &#x27;\x0B&#x27;;
                            break;
                        default:
                            if (isOctalDigit(ch)) {
                                code = &#x27;01234567&#x27;.indexOf(ch);
                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }
                                if (index &lt; length &amp;&amp; isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + &#x27;01234567&#x27;.indexOf(source[index++]);
                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if (&#x27;0123&#x27;.indexOf(ch) &gt;= 0 &amp;&amp; index &lt; length &amp;&amp; isOctalDigit(source[index])) {
                                        code = code * 8 + &#x27;01234567&#x27;.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            }
                            else {
                                str += ch;
                            }
                            break;
                    }
                }
                else {
                    ++lineNumber;
                    if (ch === &#x27;\r&#x27; &amp;&amp; source[index] === &#x27;\n&#x27;) {
                        ++index;
                    }
                    lineStart = index;
                }
            }
            else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            }
            else {
                str += ch;
            }
        }
        if (quote !== &#x27;&#x27;) {
            throwUnexpectedToken();
        }
        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function testRegExp(pattern, flags) {
        var tmp = pattern, value;
        if (flags.indexOf(&#x27;u&#x27;) &gt;= 0) {
            // Replace each astral symbol and every Unicode code point
            // escape sequence with a single ASCII symbol to avoid throwing on
            // regular expressions that are only valid in combination with the
            // &#x60;/u&#x60; flag.
            // Note: replacing with the ASCII symbol &#x60;x&#x60; might cause false
            // negatives in unlikely scenarios. For example, &#x60;[\u{61}-b]&#x60; is a
            // perfectly valid pattern that is equivalent to &#x60;[a-b]&#x60;, but it
            // would be replaced by &#x60;[x-b]&#x60; which throws an error.
            tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                if (parseInt($1, 16) &lt;= 0x10FFFF) {
                    return &#x27;x&#x27;;
                }
                throwError(Messages.InvalidRegExp);
            }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, &#x27;x&#x27;);
        }
        try {
            value = new RegExp(tmp);
        }
        catch (e) {
            throwError(Messages.InvalidRegExp);
        }
        try {
            return new RegExp(pattern, flags);
        }
        catch (exception) {
            return null;
        }
    }
    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;
        ch = source[index];
        assert(ch === &#x27;/&#x27;, &#x27;Regular expression literal must start with a slash&#x27;);
        str = source[index++];
        classMarker = false;
        terminated = false;
        while (index &lt; length) {
            ch = source[index++];
            str += ch;
            if (ch === &#x27;\\&#x27;) {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError(Messages.UnterminatedRegExp);
                }
                str += ch;
            }
            else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError(Messages.UnterminatedRegExp);
            }
            else if (classMarker) {
                if (ch === &#x27;]&#x27;) {
                    classMarker = false;
                }
            }
            else {
                if (ch === &#x27;/&#x27;) {
                    terminated = true;
                    break;
                }
                else if (ch === &#x27;[&#x27;) {
                    classMarker = true;
                }
            }
        }
        if (!terminated) {
            throwError(Messages.UnterminatedRegExp);
        }
        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }
    function scanRegExpFlags() {
        var ch, str, flags, restore;
        str = &#x27;&#x27;;
        flags = &#x27;&#x27;;
        while (index &lt; length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }
            ++index;
            if (ch === &#x27;\\&#x27; &amp;&amp; index &lt; length) {
                ch = source[index];
                if (ch === &#x27;u&#x27;) {
                    ++index;
                    restore = index;
                    ch = scanHexEscape(&#x27;u&#x27;);
                    if (ch) {
                        flags += ch;
                        for (str += &#x27;\\u&#x27;; restore &lt; index; ++restore) {
                            str += source[restore];
                        }
                    }
                    else {
                        index = restore;
                        flags += &#x27;u&#x27;;
                        str += &#x27;\\u&#x27;;
                    }
                    tolerateUnexpectedToken();
                }
                else {
                    str += &#x27;\\&#x27;;
                    tolerateUnexpectedToken();
                }
            }
            else {
                flags += ch;
                str += ch;
            }
        }
        return {
            value: flags,
            literal: str
        };
    }
    function scanRegExp() {
        var start, body, flags, value;
        lookahead = null;
        skipComment();
        start = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }
    function collectRegex() {
        var pos, loc, regex, token;
        skipComment();
        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely &#x27;/&#x27; or &#x27;/=&#x27;
            if (extra.tokens.length &gt; 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos &amp;&amp; token.type === &#x27;Punctuator&#x27;) {
                    if (token.value === &#x27;/&#x27; || token.value === &#x27;/=&#x27;) {
                        extra.tokens.pop();
                    }
                }
            }
            extra.tokens.push({
                type: &#x27;RegularExpression&#x27;,
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }
        return regex;
    }
    function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
    }
    function advanceSlash() {
        var prevToken, checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === &#x27;Punctuator&#x27;) {
            if (prevToken.value === &#x27;]&#x27;) {
                return scanPunctuator();
            }
            if (prevToken.value === &#x27;)&#x27;) {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &amp;&amp; checkToken.type === &#x27;Keyword&#x27; &amp;&amp; (checkToken.value === &#x27;if&#x27; || checkToken.value === &#x27;while&#x27; || checkToken.value === &#x27;for&#x27; || checkToken.value === &#x27;with&#x27;)) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === &#x27;}&#x27;) {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &amp;&amp; extra.tokens[extra.openCurlyToken - 3].type === &#x27;Keyword&#x27;) {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                }
                else if (extra.tokens[extra.openCurlyToken - 4] &amp;&amp; extra.tokens[extra.openCurlyToken - 4].type === &#x27;Keyword&#x27;) {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                }
                else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) &gt;= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === &#x27;Keyword&#x27; &amp;&amp; prevToken.value !== &#x27;this&#x27;) {
            return collectRegex();
        }
        return scanPunctuator();
    }
    function advance() {
        var ch;
        skipComment();
        if (index &gt;= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }
        ch = source.charCodeAt(index);
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }
        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }
        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }
        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }
        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }
        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize &amp;&amp; ch === 0x2F) {
            return advanceSlash();
        }
        return scanPunctuator();
    }
    function collectToken() {
        var loc, token, value, entry;
        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }
        return token;
    }
    function lex() {
        var token;
        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = (typeof extra.tokens !== &#x27;undefined&#x27;) ? collectToken() : advance();
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        return token;
    }
    function peek() {
        var pos, line, start;
        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== &#x27;undefined&#x27;) ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }
    function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
    }
    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }
    function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
            this.start = {
                line: startToken.startLineNumber,
                column: startToken.start - startToken.startLineStart
            };
        }
        else {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
        }
        this.end = null;
    }
    function Node() {
        // Skip comment.
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
            lineNumber = lookahead.startLineNumber;
            lineStart = lookahead.startLineStart;
        }
        else {
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
        }
        if (extra.range) {
            this.range = [index, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }
    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }
    WrappingNode.prototype = Node.prototype = {
        processComment: function () {
            var lastChild, leadingComments, trailingComments, bottomRight = extra.bottomRightStack, i, comment, last = bottomRight[bottomRight.length - 1];
            if (this.type === Syntax.Program) {
                if (this.body.length &gt; 0) {
                    return;
                }
            }
            if (extra.trailingComments.length &gt; 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i &gt;= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] &gt;= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            }
            else {
                if (last &amp;&amp; last.trailingComments &amp;&amp; last.trailingComments[0].range[0] &gt;= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }
            // Eating the stack.
            if (last) {
                while (last &amp;&amp; last.range[0] &gt;= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }
            if (lastChild) {
                if (lastChild.leadingComments &amp;&amp; lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] &lt;= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            }
            else if (extra.leadingComments.length &gt; 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i &gt;= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] &lt;= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }
            if (leadingComments &amp;&amp; leadingComments.length &gt; 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments &amp;&amp; trailingComments.length &gt; 0) {
                this.trailingComments = trailingComments;
            }
            bottomRight.push(this);
        },
        finish: function () {
            if (extra.range) {
                this.range[1] = index;
            }
            if (extra.loc) {
                this.loc.end = new Position();
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }
            if (extra.attachComment) {
                this.processComment();
            }
        },
        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },
        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },
        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },
        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === &#x27;||&#x27; || operator === &#x27;&amp;&amp;&#x27;) ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },
        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },
        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },
        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },
        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },
        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },
        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },
        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },
        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },
        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },
        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },
        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },
        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },
        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },
        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },
        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },
        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },
        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },
        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },
        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === &#x27;[&#x27;;
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },
        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },
        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },
        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },
        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            this.finish();
            return this;
        },
        finishProperty: function (kind, key, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },
        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },
        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },
        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },
        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },
        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },
        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },
        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = guardedHandlers;
            this.handlers = handlers;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },
        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === &#x27;++&#x27; || operator === &#x27;--&#x27;) ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },
        finishVariableDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },
        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },
        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },
        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        }
    };
    // Return true if there is a line terminator before the next token.
    function peekLineTerminator() {
        var pos, line, start, found;
        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;
        return found;
    }
    function createError(line, pos, description) {
        var error = new Error(&#x27;Line &#x27; + line + &#x27;: &#x27; + description);
        var e = error;
        e.index = pos;
        e.lineNumber = line;
        e.column = pos - lineStart + 1;
        e.description = description;
        return error;
    }
    // Throw an exception
    function throwError(messageFormat, arg2, agr3) {
        var args, msg;
        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert(idx &lt; args.length, &#x27;Message reference must be in range&#x27;);
            return args[idx];
        });
        throw createError(lineNumber, index, msg);
    }
    function tolerateError(messageFormat) {
        var args, msg, error;
        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert(idx &lt; args.length, &#x27;Message reference must be in range&#x27;);
            return args[idx];
        });
        error = createError(lineNumber, index, msg);
        if (extra.errors) {
            extra.errors.push(error);
        }
        else {
            throw error;
        }
    }
    // Throw an exception because of the token.
    function unexpectedTokenError(token, message) {
        var msg = Messages.UnexpectedToken;
        if (token) {
            msg = message ? message : (token.type === Token.EOF) ? Messages.UnexpectedEOS : (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier : (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber : (token.type === Token.StringLiteral) ? Messages.UnexpectedString : Messages.UnexpectedToken;
            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    msg = Messages.UnexpectedReserved;
                }
                else if (strict &amp;&amp; isStrictModeReservedWord(token.value)) {
                    msg = Messages.StrictReservedWord;
                }
            }
        }
        msg = msg.replace(&#x27;%0&#x27;, token ? token.value : &#x27;ILLEGAL&#x27;);
        return (token &amp;&amp; typeof token.lineNumber === &#x27;number&#x27;) ? createError(token.lineNumber, token.start, msg) : createError(lineNumber, index, msg);
    }
    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }
    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            extra.errors.push(error);
        }
        else {
            throw error;
        }
    }
    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.
    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }
    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to &lt;code&gt;expect(value)&lt;/code&gt;
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;
        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator &amp;&amp; token.value === &#x27;,&#x27;) {
                lex();
            }
            else if (token.type === Token.Punctuator &amp;&amp; token.value === &#x27;;&#x27;) {
                lex();
                tolerateUnexpectedToken(token);
            }
            else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        }
        else {
            expect(&#x27;,&#x27;);
        }
    }
    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.
    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }
    // Return true if the next token matches the specified punctuator.
    function match(value) {
        return lookahead.type === Token.Punctuator &amp;&amp; lookahead.value === value;
    }
    // Return true if the next token matches the specified keyword
    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword &amp;&amp; lookahead.value === keyword;
    }
    // Return true if the next token is an assignment operator
    function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === &#x27;=&#x27; || op === &#x27;*=&#x27; || op === &#x27;/=&#x27; || op === &#x27;%=&#x27; || op === &#x27;+=&#x27; || op === &#x27;-=&#x27; || op === &#x27;&lt;&lt;=&#x27; || op === &#x27;&gt;&gt;=&#x27; || op === &#x27;&gt;&gt;&gt;=&#x27; || op === &#x27;&amp;=&#x27; || op === &#x27;^=&#x27; || op === &#x27;|=&#x27;;
    }
    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber, oldLineStart = lineStart, oldLookahead = lookahead;
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(&#x27;;&#x27;)) {
            lex();
            return;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }
        if (lookahead.type !== Token.EOF &amp;&amp; !match(&#x27;}&#x27;)) {
            throwUnexpectedToken(lookahead);
        }
    }
    // Return true if provided expression is LeftHandSideExpression
    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }
    // 11.1.4 Array Initialiser
    function parseArrayInitialiser() {
        var elements = [], node = new Node();
        expect(&#x27;[&#x27;);
        while (!match(&#x27;]&#x27;)) {
            if (match(&#x27;,&#x27;)) {
                lex();
                elements.push(null);
            }
            else {
                elements.push(parseAssignmentExpression());
                if (!match(&#x27;]&#x27;)) {
                    expect(&#x27;,&#x27;);
                }
            }
        }
        lex();
        return node.finishArrayExpression(elements);
    }
    // 11.1.5 Object Initialiser
    function parsePropertyFunction(param, first) {
        var previousStrict, body, node = new Node();
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first &amp;&amp; strict &amp;&amp; isRestrictedWord(param[0].name)) {
            tolerateUnexpectedToken(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
    }
    function parsePropertyMethodFunction() {
        var previousStrict, param, method;
        previousStrict = strict;
        strict = true;
        param = parseParams();
        method = parsePropertyFunction(param.params);
        strict = previousStrict;
        return method;
    }
    function parseObjectPropertyKey() {
        var token, node = new Node();
        token = lex();
        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict &amp;&amp; token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        }
        return node.finishIdentifier(token.value);
    }
    function parseObjectProperty() {
        var token, key, id, value, param, node = new Node();
        token = lookahead;
        if (token.type === Token.Identifier) {
            id = parseObjectPropertyKey();
            // Property Assignment: Getter and Setter.
            if (token.value === &#x27;get&#x27; &amp;&amp; !(match(&#x27;:&#x27;) || match(&#x27;(&#x27;))) {
                key = parseObjectPropertyKey();
                expect(&#x27;(&#x27;);
                expect(&#x27;)&#x27;);
                value = parsePropertyFunction([]);
                return node.finishProperty(&#x27;get&#x27;, key, value, false, false);
            }
            if (token.value === &#x27;set&#x27; &amp;&amp; !(match(&#x27;:&#x27;) || match(&#x27;(&#x27;))) {
                key = parseObjectPropertyKey();
                expect(&#x27;(&#x27;);
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(&#x27;)&#x27;);
                    tolerateUnexpectedToken(token);
                    value = parsePropertyFunction([]);
                }
                else {
                    param = [parseVariableIdentifier()];
                    expect(&#x27;)&#x27;);
                    value = parsePropertyFunction(param, token);
                }
                return node.finishProperty(&#x27;set&#x27;, key, value, false, false);
            }
            if (match(&#x27;:&#x27;)) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty(&#x27;init&#x27;, id, value, false, false);
            }
            if (match(&#x27;(&#x27;)) {
                value = parsePropertyMethodFunction();
                return node.finishProperty(&#x27;init&#x27;, id, value, true, false);
            }
            value = id;
            return node.finishProperty(&#x27;init&#x27;, id, value, false, true);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpectedToken(token);
        }
        else {
            key = parseObjectPropertyKey();
            if (match(&#x27;:&#x27;)) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty(&#x27;init&#x27;, key, value, false, false);
            }
            if (match(&#x27;(&#x27;)) {
                value = parsePropertyMethodFunction();
                return node.finishProperty(&#x27;init&#x27;, key, value, true, false);
            }
            throwUnexpectedToken(lex());
        }
    }
    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();
        expect(&#x27;{&#x27;);
        while (!match(&#x27;}&#x27;)) {
            property = parseObjectProperty();
            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            }
            else {
                name = toString(property.key.value);
            }
            kind = (property.kind === &#x27;init&#x27;) ? PropertyKind.Data : (property.kind === &#x27;get&#x27;) ? PropertyKind.Get : PropertyKind.Set;
            key = &#x27;$&#x27; + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict &amp;&amp; kind === PropertyKind.Data) {
                        tolerateError(Messages.StrictDuplicateProperty);
                    }
                    else if (kind !== PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    }
                }
                else {
                    if (kind === PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    }
                    else if (map[key] &amp; kind) {
                        tolerateError(Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            }
            else {
                map[key] = kind;
            }
            properties.push(property);
            if (!match(&#x27;}&#x27;)) {
                expectCommaSeparator();
            }
        }
        expect(&#x27;}&#x27;);
        return node.finishObjectExpression(properties);
    }
    // 11.1.6 The Grouping Operator
    function parseGroupExpression() {
        var expr;
        expect(&#x27;(&#x27;);
        if (match(&#x27;)&#x27;)) {
            lex();
            return PlaceHolders.ArrowParameterPlaceHolder;
        }
        ++state.parenthesisCount;
        expr = parseExpression();
        expect(&#x27;)&#x27;);
        return expr;
    }
    // 11.1 Primary Expressions
    function parsePrimaryExpression() {
        var type, token, expr, node;
        if (match(&#x27;(&#x27;)) {
            return parseGroupExpression();
        }
        if (match(&#x27;[&#x27;)) {
            return parseArrayInitialiser();
        }
        if (match(&#x27;{&#x27;)) {
            return parseObjectInitialiser();
        }
        type = lookahead.type;
        node = new Node();
        if (type === Token.Identifier) {
            expr = node.finishIdentifier(lex().value);
        }
        else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict &amp;&amp; lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        }
        else if (type === Token.Keyword) {
            if (matchKeyword(&#x27;function&#x27;)) {
                return parseFunctionExpression();
            }
            if (matchKeyword(&#x27;this&#x27;)) {
                lex();
                expr = node.finishThisExpression();
            }
            else {
                throwUnexpectedToken(lex());
            }
        }
        else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === &#x27;true&#x27;);
            expr = node.finishLiteral(token);
        }
        else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        }
        else if (match(&#x27;/&#x27;) || match(&#x27;/=&#x27;)) {
            if (typeof extra.tokens !== &#x27;undefined&#x27;) {
                expr = node.finishLiteral(collectRegex());
            }
            else {
                expr = node.finishLiteral(scanRegExp());
            }
            peek();
        }
        else {
            throwUnexpectedToken(lex());
        }
        return expr;
    }
    // 11.2 Left-Hand-Side Expressions
    function parseArguments() {
        var args = [];
        expect(&#x27;(&#x27;);
        if (!match(&#x27;)&#x27;)) {
            while (index &lt; length) {
                args.push(parseAssignmentExpression());
                if (match(&#x27;)&#x27;)) {
                    break;
                }
                expectCommaSeparator();
            }
        }
        expect(&#x27;)&#x27;);
        return args;
    }
    function parseNonComputedProperty() {
        var token, node = new Node();
        token = lex();
        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }
        return node.finishIdentifier(token.value);
    }
    function parseNonComputedMember() {
        expect(&#x27;.&#x27;);
        return parseNonComputedProperty();
    }
    function parseComputedMember() {
        var expr;
        expect(&#x27;[&#x27;);
        expr = parseExpression();
        expect(&#x27;]&#x27;);
        return expr;
    }
    function parseNewExpression() {
        var callee, args, node = new Node();
        expectKeyword(&#x27;new&#x27;);
        callee = parseLeftHandSideExpression();
        args = match(&#x27;(&#x27;) ? parseArguments() : [];
        return node.finishNewExpression(callee, args);
    }
    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword(&#x27;new&#x27;) ? parseNewExpression() : parsePrimaryExpression();
        for (;;) {
            if (match(&#x27;.&#x27;)) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression(&#x27;.&#x27;, expr, property);
            }
            else if (match(&#x27;(&#x27;)) {
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            }
            else if (match(&#x27;[&#x27;)) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression(&#x27;[&#x27;, expr, property);
            }
            else {
                break;
            }
        }
        state.allowIn = previousAllowIn;
        return expr;
    }
    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, &#x27;callee of new expression always allow in keyword.&#x27;);
        startToken = lookahead;
        expr = matchKeyword(&#x27;new&#x27;) ? parseNewExpression() : parsePrimaryExpression();
        for (;;) {
            if (match(&#x27;[&#x27;)) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression(&#x27;[&#x27;, expr, property);
            }
            else if (match(&#x27;.&#x27;)) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression(&#x27;.&#x27;, expr, property);
            }
            else {
                break;
            }
        }
        return expr;
    }
    // 11.3 Postfix Expressions
    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;
        expr = parseLeftHandSideExpressionAllowCall();
        if (lookahead.type === Token.Punctuator) {
            if ((match(&#x27;++&#x27;) || match(&#x27;--&#x27;)) &amp;&amp; !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }
                if (!isLeftHandSide(expr)) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }
                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }
        return expr;
    }
    // 11.4 Unary Operators
    function parseUnaryExpression() {
        var token, expr, startToken;
        if (lookahead.type !== Token.Punctuator &amp;&amp; lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        }
        else if (match(&#x27;++&#x27;) || match(&#x27;--&#x27;)) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }
            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        }
        else if (match(&#x27;+&#x27;) || match(&#x27;-&#x27;) || match(&#x27;~&#x27;) || match(&#x27;!&#x27;)) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        }
        else if (matchKeyword(&#x27;delete&#x27;) || matchKeyword(&#x27;void&#x27;) || matchKeyword(&#x27;typeof&#x27;)) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict &amp;&amp; expr.operator === &#x27;delete&#x27; &amp;&amp; expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
        }
        else {
            expr = parsePostfixExpression();
        }
        return expr;
    }
    function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator &amp;&amp; token.type !== Token.Keyword) {
            return 0;
        }
        switch (token.value) {
            case &#x27;||&#x27;:
                prec = 1;
                break;
            case &#x27;&amp;&amp;&#x27;:
                prec = 2;
                break;
            case &#x27;&amp;&#x27;:
                prec = 3;
                break;
            case &#x27;==&#x27;:
            case &#x27;!=&#x27;:
            case &#x27;===&#x27;:
            case &#x27;!==&#x27;:
                prec = 4;
                break;
            case &#x27;&lt;&#x27;:
            case &#x27;&gt;&#x27;:
            case &#x27;&lt;=&#x27;:
            case &#x27;&gt;=&#x27;:
            case &#x27;instanceof&#x27;:
                prec = 5;
                break;
            case &#x27;in&#x27;:
                prec = allowIn ? 6 : 0;
                break;
            case &#x27;&gt;&gt;&gt;&#x27;:
                prec = 7;
                break;
            case &#x27;+&#x27;:
            case &#x27;-&#x27;:
                prec = 8;
                break;
            case &#x27;*&#x27;:
            case &#x27;/&#x27;:
                prec = 9;
                break;
            case &#x27;^&#x27;:
                prec = 10;
                break;
            case &#x27;|&#x27;:
                prec = 11;
                break;
            case &#x27;%&#x27;:
            case &#x27;&lt;&lt;&#x27;:
            case &#x27;&gt;&gt;&#x27;:
                prec = 12;
                break;
            default:
                break;
        }
        return prec;
    }
    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators
    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;
        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
            return left;
        }
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();
        markers = [marker, lookahead];
        right = parseUnaryExpression();
        stack = [left, token, right];
        while ((prec = binaryPrecedence(lookahead, state.allowIn)) &gt; 0) {
            while ((stack.length &gt; 2) &amp;&amp; (prec &lt;= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }
            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }
        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i &gt; 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }
        return expr;
    }
    // 11.12 Conditional Operator
    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;
        startToken = lookahead;
        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
            return expr;
        }
        if (match(&#x27;?&#x27;)) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(&#x27;:&#x27;);
            alternate = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }
        return expr;
    }
    // [ES6] 14.2 Arrow Function
    function parseConciseBody() {
        if (match(&#x27;{&#x27;)) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }
    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest, token;
        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };
        for (i = 0, len = expressions.length; i &lt; len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            }
            else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            }
            else {
                return null;
            }
        }
        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }
        if (defaultCount === 0) {
            defaults = [];
        }
        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }
    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;
        expect(&#x27;=&gt;&#x27;);
        previousStrict = strict;
        body = parseConciseBody();
        if (strict &amp;&amp; options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict &amp;&amp; options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }
        strict = previousStrict;
        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }
    // 11.13 Assignment Operators
    function parseAssignmentExpression() {
        var oldParenthesisCount, token, expr, right, list, startToken;
        oldParenthesisCount = state.parenthesisCount;
        startToken = lookahead;
        token = lookahead;
        expr = parseConditionalExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match(&#x27;=&gt;&#x27;)) {
            if (state.parenthesisCount === oldParenthesisCount || state.parenthesisCount === (oldParenthesisCount + 1)) {
                if (expr.type === Syntax.Identifier) {
                    list = reinterpretAsCoverFormalsList([expr]);
                }
                else if (expr.type === Syntax.AssignmentExpression) {
                    list = reinterpretAsCoverFormalsList([expr]);
                }
                else if (expr.type === Syntax.SequenceExpression) {
                    list = reinterpretAsCoverFormalsList(expr.expressions);
                }
                else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
                    list = reinterpretAsCoverFormalsList([]);
                }
                if (list) {
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
            }
        }
        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            // 11.13.1
            if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
            }
            token = lex();
            right = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }
        return expr;
    }
    // 11.14 Comma Operator
    function parseExpression() {
        var expr, startToken = lookahead, expressions;
        expr = parseAssignmentExpression();
        if (match(&#x27;,&#x27;)) {
            expressions = [expr];
            while (index &lt; length) {
                if (!match(&#x27;,&#x27;)) {
                    break;
                }
                lex();
                expressions.push(parseAssignmentExpression());
            }
            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }
        return expr;
    }
    // 12.1 Block
    function parseStatementList() {
        var list = [], statement;
        while (index &lt; length) {
            if (match(&#x27;}&#x27;)) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === &#x27;undefined&#x27;) {
                break;
            }
            list.push(statement);
        }
        return list;
    }
    function parseBlock() {
        var block, node = new Node();
        expect(&#x27;{&#x27;);
        block = parseStatementList();
        expect(&#x27;}&#x27;);
        return node.finishBlockStatement(block);
    }
    // 12.2 Variable Statement
    function parseVariableIdentifier() {
        var token, node = new Node();
        token = lex();
        if (token.type !== Token.Identifier) {
            if (strict &amp;&amp; token.type === Token.Keyword &amp;&amp; isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            }
            else {
                throwUnexpectedToken(token);
            }
        }
        return node.finishIdentifier(token.value);
    }
    function parseVariableDeclaration(kind) {
        var init = null, id, node = new Node();
        id = parseVariableIdentifier();
        // 12.2.1
        if (strict &amp;&amp; isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }
        if (kind === &#x27;const&#x27;) {
            expect(&#x27;=&#x27;);
            init = parseAssignmentExpression();
        }
        else if (match(&#x27;=&#x27;)) {
            lex();
            init = parseAssignmentExpression();
        }
        return node.finishVariableDeclarator(id, init);
    }
    function parseVariableDeclarationList(kind) {
        var list = [];
        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(&#x27;,&#x27;)) {
                break;
            }
            lex();
        } while (index &lt; length);
        return list;
    }
    function parseVariableStatement(node) {
        var declarations;
        expectKeyword(&#x27;var&#x27;);
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return node.finishVariableDeclaration(declarations, &#x27;var&#x27;);
    }
    // kind may be &#x60;const&#x60; or &#x60;let&#x60;
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, node = new Node();
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return node.finishVariableDeclaration(declarations, kind);
    }
    // 12.3 Empty Statement
    function parseEmptyStatement(ignore) {
        var node = new Node();
        expect(&#x27;;&#x27;);
        return node.finishEmptyStatement();
    }
    // 12.4 Expression Statement
    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }
    // 12.5 If statement
    function parseIfStatement(node) {
        var test, consequent, alternate;
        expectKeyword(&#x27;if&#x27;);
        expect(&#x27;(&#x27;);
        test = parseExpression();
        expect(&#x27;)&#x27;);
        consequent = parseStatement();
        if (matchKeyword(&#x27;else&#x27;)) {
            lex();
            alternate = parseStatement();
        }
        else {
            alternate = null;
        }
        return node.finishIfStatement(test, consequent, alternate);
    }
    // 12.6 Iteration Statements
    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;
        expectKeyword(&#x27;do&#x27;);
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword(&#x27;while&#x27;);
        expect(&#x27;(&#x27;);
        test = parseExpression();
        expect(&#x27;)&#x27;);
        if (match(&#x27;;&#x27;)) {
            lex();
        }
        return node.finishDoWhileStatement(body, test);
    }
    function parseWhileStatement(node) {
        var test, body, oldInIteration;
        expectKeyword(&#x27;while&#x27;);
        expect(&#x27;(&#x27;);
        test = parseExpression();
        expect(&#x27;)&#x27;);
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return node.finishWhileStatement(test, body);
    }
    function parseForVariableDeclaration() {
        var token, declarations, node = new Node();
        token = lex();
        declarations = parseVariableDeclarationList();
        return node.finishVariableDeclaration(declarations, token.value);
    }
    function parseForStatement(node) {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;
        init = test = update = null;
        expectKeyword(&#x27;for&#x27;);
        expect(&#x27;(&#x27;);
        if (match(&#x27;;&#x27;)) {
            lex();
        }
        else {
            if (matchKeyword(&#x27;var&#x27;) || matchKeyword(&#x27;let&#x27;)) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;
                if (init.declarations.length === 1 &amp;&amp; matchKeyword(&#x27;in&#x27;)) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }
            else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;
                if (matchKeyword(&#x27;in&#x27;)) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }
            if (typeof left === &#x27;undefined&#x27;) {
                expect(&#x27;;&#x27;);
            }
        }
        if (typeof left === &#x27;undefined&#x27;) {
            if (!match(&#x27;;&#x27;)) {
                test = parseExpression();
            }
            expect(&#x27;;&#x27;);
            if (!match(&#x27;)&#x27;)) {
                update = parseExpression();
            }
        }
        expect(&#x27;)&#x27;);
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return (typeof left === &#x27;undefined&#x27;) ? node.finishForStatement(init, test, update, body) : node.finishForInStatement(left, right, body);
    }
    // 12.7 The continue statement
    function parseContinueStatement(node) {
        var label = null, key;
        expectKeyword(&#x27;continue&#x27;);
        // Optimize the most common form: &#x27;continue;&#x27;.
        if (source.charCodeAt(index) === 0x3B) {
            lex();
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }
            return node.finishContinueStatement(null);
        }
        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }
            return node.finishContinueStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = &#x27;$&#x27; + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }
        consumeSemicolon();
        if (label === null &amp;&amp; !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }
        return node.finishContinueStatement(label);
    }
    // 12.8 The break statement
    function parseBreakStatement(node) {
        var label = null, key;
        expectKeyword(&#x27;break&#x27;);
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
            return node.finishBreakStatement(null);
        }
        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
            return node.finishBreakStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = &#x27;$&#x27; + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }
        consumeSemicolon();
        if (label === null &amp;&amp; !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }
        return node.finishBreakStatement(label);
    }
    // 12.9 The return statement
    function parseReturnStatement(node) {
        var argument = null;
        expectKeyword(&#x27;return&#x27;);
        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }
        // &#x27;return&#x27; followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }
        if (peekLineTerminator()) {
            return node.finishReturnStatement(null);
        }
        if (!match(&#x27;;&#x27;)) {
            if (!match(&#x27;}&#x27;) &amp;&amp; lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }
        consumeSemicolon();
        return node.finishReturnStatement(argument);
    }
    // 12.10 The with statement
    function parseWithStatement(node) {
        var object, body;
        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            tolerateError(Messages.StrictModeWith);
        }
        expectKeyword(&#x27;with&#x27;);
        expect(&#x27;(&#x27;);
        object = parseExpression();
        expect(&#x27;)&#x27;);
        body = parseStatement();
        return node.finishWithStatement(object, body);
    }
    // 12.10 The swith statement
    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();
        if (matchKeyword(&#x27;default&#x27;)) {
            lex();
            test = null;
        }
        else {
            expectKeyword(&#x27;case&#x27;);
            test = parseExpression();
        }
        expect(&#x27;:&#x27;);
        while (index &lt; length) {
            if (match(&#x27;}&#x27;) || matchKeyword(&#x27;default&#x27;) || matchKeyword(&#x27;case&#x27;)) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }
        return node.finishSwitchCase(test, consequent);
    }
    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;
        expectKeyword(&#x27;switch&#x27;);
        expect(&#x27;(&#x27;);
        discriminant = parseExpression();
        expect(&#x27;)&#x27;);
        expect(&#x27;{&#x27;);
        cases = [];
        if (match(&#x27;}&#x27;)) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (index &lt; length) {
            if (match(&#x27;}&#x27;)) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect(&#x27;}&#x27;);
        return node.finishSwitchStatement(discriminant, cases);
    }
    // 12.13 The throw statement
    function parseThrowStatement(node) {
        var argument;
        expectKeyword(&#x27;throw&#x27;);
        if (peekLineTerminator()) {
            throwError(Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return node.finishThrowStatement(argument);
    }
    // 12.14 The try statement
    function parseCatchClause() {
        var param, body, node = new Node();
        expectKeyword(&#x27;catch&#x27;);
        expect(&#x27;(&#x27;);
        if (match(&#x27;)&#x27;)) {
            throwUnexpectedToken(lookahead);
        }
        param = parseVariableIdentifier();
        // 12.14.1
        if (strict &amp;&amp; isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }
        expect(&#x27;)&#x27;);
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }
    function parseTryStatement(node) {
        var block, handlers = [], finalizer = null;
        expectKeyword(&#x27;try&#x27;);
        block = parseBlock();
        if (matchKeyword(&#x27;catch&#x27;)) {
            handlers.push(parseCatchClause());
        }
        if (matchKeyword(&#x27;finally&#x27;)) {
            lex();
            finalizer = parseBlock();
        }
        if (handlers.length === 0 &amp;&amp; !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }
        return node.finishTryStatement(block, [], handlers, finalizer);
    }
    // 12.15 The debugger statement
    function parseDebuggerStatement(node) {
        expectKeyword(&#x27;debugger&#x27;);
        consumeSemicolon();
        return node.finishDebuggerStatement();
    }
    // 12 Statements
    function parseStatement() {
        var type = lookahead.type, expr, labeledBody, key, node;
        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }
        if (type === Token.Punctuator &amp;&amp; lookahead.value === &#x27;{&#x27;) {
            return parseBlock();
        }
        node = new Node();
        if (type === Token.Punctuator) {
            switch (lookahead.value) {
                case &#x27;;&#x27;:
                    return parseEmptyStatement(node);
                case &#x27;(&#x27;:
                    return parseExpressionStatement(node);
                default:
                    break;
            }
        }
        else if (type === Token.Keyword) {
            switch (lookahead.value) {
                case &#x27;break&#x27;:
                    return parseBreakStatement(node);
                case &#x27;continue&#x27;:
                    return parseContinueStatement(node);
                case &#x27;debugger&#x27;:
                    return parseDebuggerStatement(node);
                case &#x27;do&#x27;:
                    return parseDoWhileStatement(node);
                case &#x27;for&#x27;:
                    return parseForStatement(node);
                case &#x27;function&#x27;:
                    return parseFunctionDeclaration(node);
                case &#x27;if&#x27;:
                    return parseIfStatement(node);
                case &#x27;return&#x27;:
                    return parseReturnStatement(node);
                case &#x27;switch&#x27;:
                    return parseSwitchStatement(node);
                case &#x27;throw&#x27;:
                    return parseThrowStatement(node);
                case &#x27;try&#x27;:
                    return parseTryStatement(node);
                case &#x27;var&#x27;:
                    return parseVariableStatement(node);
                case &#x27;while&#x27;:
                    return parseWhileStatement(node);
                case &#x27;with&#x27;:
                    return parseWithStatement(node);
                default:
                    break;
            }
        }
        expr = parseExpression();
        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) &amp;&amp; match(&#x27;:&#x27;)) {
            lex();
            key = &#x27;$&#x27; + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, &#x27;Label&#x27;, expr.name);
            }
            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }
    // 13 Function Definition
    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount, node = new Node();
        expect(&#x27;{&#x27;);
        while (index &lt; length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;
            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === &#x27;use strict&#x27;) {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            }
            else {
                if (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;
        while (index &lt; length) {
            if (match(&#x27;}&#x27;)) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === &#x27;undefined&#x27;) {
                break;
            }
            sourceElements.push(sourceElement);
        }
        expect(&#x27;}&#x27;);
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;
        return node.finishBlockStatement(sourceElements);
    }
    function validateParam(options, param, name) {
        var key = &#x27;$&#x27; + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            }
            else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            }
            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }
    function parseParam(options) {
        var token, param, def;
        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match(&#x27;=&#x27;)) {
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }
        options.params.push(param);
        options.defaults.push(def);
        return !match(&#x27;)&#x27;);
    }
    function parseParams(firstRestricted) {
        var options;
        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };
        expect(&#x27;(&#x27;);
        if (!match(&#x27;)&#x27;)) {
            options.paramSet = {};
            while (index &lt; length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(&#x27;,&#x27;);
            }
        }
        expect(&#x27;)&#x27;);
        if (options.defaultCount === 0) {
            options.defaults = [];
        }
        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }
    function parseFunctionDeclaration(ignore) {
        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();
        expectKeyword(&#x27;function&#x27;);
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictFunctionName);
            }
        }
        else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            }
            else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict &amp;&amp; firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict &amp;&amp; stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        return node.finishFunctionDeclaration(id, params, defaults, body);
    }
    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], defaults = [], body, previousStrict, node = new Node();
        expectKeyword(&#x27;function&#x27;);
        if (!match(&#x27;(&#x27;)) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            }
            else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                }
                else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict &amp;&amp; firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict &amp;&amp; stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(id, params, defaults, body);
    }
    // 14 Program
    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
                case &#x27;const&#x27;:
                case &#x27;let&#x27;:
                    return parseConstLetDeclaration(lookahead.value);
                case &#x27;function&#x27;:
                    return parseFunctionDeclaration();
                default:
                    return parseStatement();
            }
        }
        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }
    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;
        while (index &lt; length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }
            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === &#x27;use strict&#x27;) {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            }
            else {
                if (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }
        while (index &lt; length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === &#x27;undefined&#x27;) {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }
    function parseProgram() {
        var body, node;
        skipComment();
        peek();
        node = new Node();
        strict = false;
        body = parseSourceElements();
        return node.finishProgram(body);
    }
    function filterTokenLocation() {
        var i, entry, token, tokens = [];
        for (i = 0; i &lt; extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }
        extra.tokens = tokens;
    }
    function tokenize(code, options) {
        var toString, tokens;
        toString = String;
        if (typeof code !== &#x27;string&#x27; &amp;&amp; !(code instanceof String)) {
            code = toString(code);
        }
        source = code;
        index = 0;
        lineNumber = (source.length &gt; 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };
        extra = {};
        // Options matching.
        options = options || {};
        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = (typeof options.range === &#x27;boolean&#x27;) &amp;&amp; options.range;
        extra.loc = (typeof options.loc === &#x27;boolean&#x27;) &amp;&amp; options.loc;
        if (typeof options.comment === &#x27;boolean&#x27; &amp;&amp; options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === &#x27;boolean&#x27; &amp;&amp; options.tolerant) {
            extra.errors = [];
        }
        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }
            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                }
                catch (lexError) {
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        break;
                    }
                    else {
                        throw lexError;
                    }
                }
            }
            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== &#x27;undefined&#x27;) {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== &#x27;undefined&#x27;) {
                tokens.errors = extra.errors;
            }
        }
        catch (e) {
            throw e;
        }
        finally {
            extra = {};
        }
        return tokens;
    }
    function parse(code, options) {
        var program, toString;
        toString = String;
        if (typeof code !== &#x27;string&#x27; &amp;&amp; !(code instanceof String)) {
            code = toString(code);
        }
        source = code;
        index = 0;
        lineNumber = (source.length &gt; 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            parenthesisCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };
        extra = {};
        if (typeof options !== &#x27;undefined&#x27;) {
            extra.range = (typeof options.range === &#x27;boolean&#x27;) &amp;&amp; options.range;
            extra.loc = (typeof options.loc === &#x27;boolean&#x27;) &amp;&amp; options.loc;
            extra.attachComment = (typeof options.attachComment === &#x27;boolean&#x27;) &amp;&amp; options.attachComment;
            if (extra.loc &amp;&amp; options.source !== null &amp;&amp; options.source !== undefined) {
                extra.source = toString(options.source);
            }
            if (typeof options.tokens === &#x27;boolean&#x27; &amp;&amp; options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === &#x27;boolean&#x27; &amp;&amp; options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === &#x27;boolean&#x27; &amp;&amp; options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }
        try {
            program = parseProgram();
            if (typeof extra.comments !== &#x27;undefined&#x27;) {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== &#x27;undefined&#x27;) {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== &#x27;undefined&#x27;) {
                program.errors = extra.errors;
            }
        }
        catch (e) {
            throw e;
        }
        finally {
            extra = {};
        }
        return program;
    }
    // Deep copy.
    /* istanbul ignore next */
    var esprimaSyntax = (function () {
        var name, types = {};
        if (typeof Object.create === &#x27;function&#x27;) {
            types = Object.create(null);
        }
        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }
        if (typeof Object.freeze === &#x27;function&#x27;) {
            Object.freeze(types);
        }
        return types;
    }());
    var esprima = {
        tokenize: tokenize,
        parse: parse,
        Synatax: esprimaSyntax
    };
    return esprima;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
